// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "biblioteca.hxx"

namespace gestColl
{
  namespace biblioteca
  {
    // autori
    // 

    const autori::autore_sequence& autori::
    autore () const
    {
      return this->autore_;
    }

    autori::autore_sequence& autori::
    autore ()
    {
      return this->autore_;
    }

    void autori::
    autore (const autore_sequence& s)
    {
      this->autore_ = s;
    }


    // supporti
    // 

    const supporti::supporto_sequence& supporti::
    supporto () const
    {
      return this->supporto_;
    }

    supporti::supporto_sequence& supporti::
    supporto ()
    {
      return this->supporto_;
    }

    void supporti::
    supporto (const supporto_sequence& s)
    {
      this->supporto_ = s;
    }


    // argomenti
    // 

    const argomenti::argomento_sequence& argomenti::
    argomento () const
    {
      return this->argomento_;
    }

    argomenti::argomento_sequence& argomenti::
    argomento ()
    {
      return this->argomento_;
    }

    void argomenti::
    argomento (const argomento_sequence& s)
    {
      this->argomento_ = s;
    }


    // librotype
    // 

    const librotype::id_type& librotype::
    id () const
    {
      return this->id_.get ();
    }

    librotype::id_type& librotype::
    id ()
    {
      return this->id_.get ();
    }

    void librotype::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void librotype::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }

    const librotype::autori_optional& librotype::
    autori () const
    {
      return this->autori_;
    }

    librotype::autori_optional& librotype::
    autori ()
    {
      return this->autori_;
    }

    void librotype::
    autori (const autori_type& x)
    {
      this->autori_.set (x);
    }

    void librotype::
    autori (const autori_optional& x)
    {
      this->autori_ = x;
    }

    void librotype::
    autori (::std::auto_ptr< autori_type > x)
    {
      this->autori_.set (x);
    }

    const librotype::titolo_type& librotype::
    titolo () const
    {
      return this->titolo_.get ();
    }

    librotype::titolo_type& librotype::
    titolo ()
    {
      return this->titolo_.get ();
    }

    void librotype::
    titolo (const titolo_type& x)
    {
      this->titolo_.set (x);
    }

    void librotype::
    titolo (::std::auto_ptr< titolo_type > x)
    {
      this->titolo_.set (x);
    }

    const librotype::supporti_optional& librotype::
    supporti () const
    {
      return this->supporti_;
    }

    librotype::supporti_optional& librotype::
    supporti ()
    {
      return this->supporti_;
    }

    void librotype::
    supporti (const supporti_type& x)
    {
      this->supporti_.set (x);
    }

    void librotype::
    supporti (const supporti_optional& x)
    {
      this->supporti_ = x;
    }

    void librotype::
    supporti (::std::auto_ptr< supporti_type > x)
    {
      this->supporti_.set (x);
    }

    const librotype::filename_optional& librotype::
    filename () const
    {
      return this->filename_;
    }

    librotype::filename_optional& librotype::
    filename ()
    {
      return this->filename_;
    }

    void librotype::
    filename (const filename_type& x)
    {
      this->filename_.set (x);
    }

    void librotype::
    filename (const filename_optional& x)
    {
      this->filename_ = x;
    }

    void librotype::
    filename (::std::auto_ptr< filename_type > x)
    {
      this->filename_.set (x);
    }

    const librotype::argomenti_optional& librotype::
    argomenti () const
    {
      return this->argomenti_;
    }

    librotype::argomenti_optional& librotype::
    argomenti ()
    {
      return this->argomenti_;
    }

    void librotype::
    argomenti (const argomenti_type& x)
    {
      this->argomenti_.set (x);
    }

    void librotype::
    argomenti (const argomenti_optional& x)
    {
      this->argomenti_ = x;
    }

    void librotype::
    argomenti (::std::auto_ptr< argomenti_type > x)
    {
      this->argomenti_.set (x);
    }


    // libri
    // 

    const libri::libro_sequence& libri::
    libro () const
    {
      return this->libro_;
    }

    libri::libro_sequence& libri::
    libro ()
    {
      return this->libro_;
    }

    void libri::
    libro (const libro_sequence& s)
    {
      this->libro_ = s;
    }


    // cataloghi
    // 

    const cataloghi::catalogo_sequence& cataloghi::
    catalogo () const
    {
      return this->catalogo_;
    }

    cataloghi::catalogo_sequence& cataloghi::
    catalogo ()
    {
      return this->catalogo_;
    }

    void cataloghi::
    catalogo (const catalogo_sequence& s)
    {
      this->catalogo_ = s;
    }


    // catalogo
    // 

    const catalogo::autori_type& catalogo::
    autori () const
    {
      return this->autori_.get ();
    }

    catalogo::autori_type& catalogo::
    autori ()
    {
      return this->autori_.get ();
    }

    void catalogo::
    autori (const autori_type& x)
    {
      this->autori_.set (x);
    }

    void catalogo::
    autori (::std::auto_ptr< autori_type > x)
    {
      this->autori_.set (x);
    }

    const catalogo::numero_type& catalogo::
    numero () const
    {
      return this->numero_.get ();
    }

    catalogo::numero_type& catalogo::
    numero ()
    {
      return this->numero_.get ();
    }

    void catalogo::
    numero (const numero_type& x)
    {
      this->numero_.set (x);
    }

    void catalogo::
    numero (::std::auto_ptr< numero_type > x)
    {
      this->numero_.set (x);
    }

    const catalogo::data_optional& catalogo::
    data () const
    {
      return this->data_;
    }

    catalogo::data_optional& catalogo::
    data ()
    {
      return this->data_;
    }

    void catalogo::
    data (const data_type& x)
    {
      this->data_.set (x);
    }

    void catalogo::
    data (const data_optional& x)
    {
      this->data_ = x;
    }

    void catalogo::
    data (::std::auto_ptr< data_type > x)
    {
      this->data_.set (x);
    }

    const catalogo::filename_optional& catalogo::
    filename () const
    {
      return this->filename_;
    }

    catalogo::filename_optional& catalogo::
    filename ()
    {
      return this->filename_;
    }

    void catalogo::
    filename (const filename_type& x)
    {
      this->filename_.set (x);
    }

    void catalogo::
    filename (const filename_optional& x)
    {
      this->filename_ = x;
    }

    void catalogo::
    filename (::std::auto_ptr< filename_type > x)
    {
      this->filename_.set (x);
    }

    const catalogo::supporti_optional& catalogo::
    supporti () const
    {
      return this->supporti_;
    }

    catalogo::supporti_optional& catalogo::
    supporti ()
    {
      return this->supporti_;
    }

    void catalogo::
    supporti (const supporti_type& x)
    {
      this->supporti_.set (x);
    }

    void catalogo::
    supporti (const supporti_optional& x)
    {
      this->supporti_ = x;
    }

    void catalogo::
    supporti (::std::auto_ptr< supporti_type > x)
    {
      this->supporti_.set (x);
    }

    const catalogo::argomenti_optional& catalogo::
    argomenti () const
    {
      return this->argomenti_;
    }

    catalogo::argomenti_optional& catalogo::
    argomenti ()
    {
      return this->argomenti_;
    }

    void catalogo::
    argomenti (const argomenti_type& x)
    {
      this->argomenti_.set (x);
    }

    void catalogo::
    argomenti (const argomenti_optional& x)
    {
      this->argomenti_ = x;
    }

    void catalogo::
    argomenti (::std::auto_ptr< argomenti_type > x)
    {
      this->argomenti_.set (x);
    }


    // biblioteca
    // 

    const biblioteca::libri_type& biblioteca::
    libri () const
    {
      return this->libri_.get ();
    }

    biblioteca::libri_type& biblioteca::
    libri ()
    {
      return this->libri_.get ();
    }

    void biblioteca::
    libri (const libri_type& x)
    {
      this->libri_.set (x);
    }

    void biblioteca::
    libri (::std::auto_ptr< libri_type > x)
    {
      this->libri_.set (x);
    }

    const biblioteca::cataloghi_type& biblioteca::
    cataloghi () const
    {
      return this->cataloghi_.get ();
    }

    biblioteca::cataloghi_type& biblioteca::
    cataloghi ()
    {
      return this->cataloghi_.get ();
    }

    void biblioteca::
    cataloghi (const cataloghi_type& x)
    {
      this->cataloghi_.set (x);
    }

    void biblioteca::
    cataloghi (::std::auto_ptr< cataloghi_type > x)
    {
      this->cataloghi_.set (x);
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace gestColl
{
  namespace biblioteca
  {
    // autori
    //

    autori::
    autori ()
    : ::xml_schema::type (),
      autore_ (this)
    {
    }

    autori::
    autori (const autori& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      autore_ (x.autore_, f, this)
    {
    }

    autori::
    autori (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      autore_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void autori::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // autore
        //
        if (n.name () == L"autore" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< autore_type > r (
            autore_traits::create (i, f, this));

          this->autore_.push_back (r);
          continue;
        }

        break;
      }
    }

    autori* autori::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class autori (*this, f, c);
    }

    autori& autori::
    operator= (const autori& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->autore_ = x.autore_;
      }

      return *this;
    }

    autori::
    ~autori ()
    {
    }

    // supporti
    //

    supporti::
    supporti ()
    : ::xml_schema::type (),
      supporto_ (this)
    {
    }

    supporti::
    supporti (const supporti& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      supporto_ (x.supporto_, f, this)
    {
    }

    supporti::
    supporti (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      supporto_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void supporti::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // supporto
        //
        if (n.name () == L"supporto" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< supporto_type > r (
            supporto_traits::create (i, f, this));

          this->supporto_.push_back (r);
          continue;
        }

        break;
      }
    }

    supporti* supporti::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class supporti (*this, f, c);
    }

    supporti& supporti::
    operator= (const supporti& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->supporto_ = x.supporto_;
      }

      return *this;
    }

    supporti::
    ~supporti ()
    {
    }

    // argomenti
    //

    argomenti::
    argomenti ()
    : ::xml_schema::type (),
      argomento_ (this)
    {
    }

    argomenti::
    argomenti (const argomenti& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      argomento_ (x.argomento_, f, this)
    {
    }

    argomenti::
    argomenti (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      argomento_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void argomenti::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // argomento
        //
        if (n.name () == L"argomento" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< argomento_type > r (
            argomento_traits::create (i, f, this));

          this->argomento_.push_back (r);
          continue;
        }

        break;
      }
    }

    argomenti* argomenti::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class argomenti (*this, f, c);
    }

    argomenti& argomenti::
    operator= (const argomenti& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->argomento_ = x.argomento_;
      }

      return *this;
    }

    argomenti::
    ~argomenti ()
    {
    }

    // librotype
    //

    librotype::
    librotype (const id_type& id,
               const titolo_type& titolo)
    : ::xml_schema::type (),
      id_ (id, this),
      autori_ (this),
      titolo_ (titolo, this),
      supporti_ (this),
      filename_ (this),
      argomenti_ (this)
    {
    }

    librotype::
    librotype (const librotype& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      id_ (x.id_, f, this),
      autori_ (x.autori_, f, this),
      titolo_ (x.titolo_, f, this),
      supporti_ (x.supporti_, f, this),
      filename_ (x.filename_, f, this),
      argomenti_ (x.argomenti_, f, this)
    {
    }

    librotype::
    librotype (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      id_ (this),
      autori_ (this),
      titolo_ (this),
      supporti_ (this),
      filename_ (this),
      argomenti_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void librotype::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // id
        //
        if (n.name () == L"id" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          if (!id_.present ())
          {
            this->id_.set (r);
            continue;
          }
        }

        // autori
        //
        if (n.name () == L"autori" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< autori_type > r (
            autori_traits::create (i, f, this));

          if (!this->autori_)
          {
            this->autori_.set (r);
            continue;
          }
        }

        // titolo
        //
        if (n.name () == L"titolo" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< titolo_type > r (
            titolo_traits::create (i, f, this));

          if (!titolo_.present ())
          {
            this->titolo_.set (r);
            continue;
          }
        }

        // supporti
        //
        if (n.name () == L"supporti" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< supporti_type > r (
            supporti_traits::create (i, f, this));

          if (!this->supporti_)
          {
            this->supporti_.set (r);
            continue;
          }
        }

        // filename
        //
        if (n.name () == L"filename" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< filename_type > r (
            filename_traits::create (i, f, this));

          if (!this->filename_)
          {
            this->filename_.set (r);
            continue;
          }
        }

        // argomenti
        //
        if (n.name () == L"argomenti" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< argomenti_type > r (
            argomenti_traits::create (i, f, this));

          if (!this->argomenti_)
          {
            this->argomenti_.set (r);
            continue;
          }
        }

        break;
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"id",
          L"http://gestColl/biblioteca");
      }

      if (!titolo_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"titolo",
          L"http://gestColl/biblioteca");
      }
    }

    librotype* librotype::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class librotype (*this, f, c);
    }

    librotype& librotype::
    operator= (const librotype& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->id_ = x.id_;
        this->autori_ = x.autori_;
        this->titolo_ = x.titolo_;
        this->supporti_ = x.supporti_;
        this->filename_ = x.filename_;
        this->argomenti_ = x.argomenti_;
      }

      return *this;
    }

    librotype::
    ~librotype ()
    {
    }

    // libri
    //

    libri::
    libri ()
    : ::xml_schema::type (),
      libro_ (this)
    {
    }

    libri::
    libri (const libri& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      libro_ (x.libro_, f, this)
    {
    }

    libri::
    libri (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      libro_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void libri::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // libro
        //
        if (n.name () == L"libro" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< libro_type > r (
            libro_traits::create (i, f, this));

          this->libro_.push_back (r);
          continue;
        }

        break;
      }
    }

    libri* libri::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class libri (*this, f, c);
    }

    libri& libri::
    operator= (const libri& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->libro_ = x.libro_;
      }

      return *this;
    }

    libri::
    ~libri ()
    {
    }

    // cataloghi
    //

    cataloghi::
    cataloghi ()
    : ::xml_schema::type (),
      catalogo_ (this)
    {
    }

    cataloghi::
    cataloghi (const cataloghi& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      catalogo_ (x.catalogo_, f, this)
    {
    }

    cataloghi::
    cataloghi (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      catalogo_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void cataloghi::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // catalogo
        //
        if (n.name () == L"catalogo" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< catalogo_type > r (
            catalogo_traits::create (i, f, this));

          this->catalogo_.push_back (r);
          continue;
        }

        break;
      }
    }

    cataloghi* cataloghi::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class cataloghi (*this, f, c);
    }

    cataloghi& cataloghi::
    operator= (const cataloghi& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->catalogo_ = x.catalogo_;
      }

      return *this;
    }

    cataloghi::
    ~cataloghi ()
    {
    }

    // catalogo
    //

    catalogo::
    catalogo (const autori_type& autori,
              const numero_type& numero)
    : ::xml_schema::type (),
      autori_ (autori, this),
      numero_ (numero, this),
      data_ (this),
      filename_ (this),
      supporti_ (this),
      argomenti_ (this)
    {
    }

    catalogo::
    catalogo (::std::auto_ptr< autori_type > autori,
              const numero_type& numero)
    : ::xml_schema::type (),
      autori_ (autori, this),
      numero_ (numero, this),
      data_ (this),
      filename_ (this),
      supporti_ (this),
      argomenti_ (this)
    {
    }

    catalogo::
    catalogo (const catalogo& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      autori_ (x.autori_, f, this),
      numero_ (x.numero_, f, this),
      data_ (x.data_, f, this),
      filename_ (x.filename_, f, this),
      supporti_ (x.supporti_, f, this),
      argomenti_ (x.argomenti_, f, this)
    {
    }

    catalogo::
    catalogo (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      autori_ (this),
      numero_ (this),
      data_ (this),
      filename_ (this),
      supporti_ (this),
      argomenti_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void catalogo::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // autori
        //
        if (n.name () == L"autori" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< autori_type > r (
            autori_traits::create (i, f, this));

          if (!autori_.present ())
          {
            this->autori_.set (r);
            continue;
          }
        }

        // numero
        //
        if (n.name () == L"numero" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< numero_type > r (
            numero_traits::create (i, f, this));

          if (!numero_.present ())
          {
            this->numero_.set (r);
            continue;
          }
        }

        // data
        //
        if (n.name () == L"data" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< data_type > r (
            data_traits::create (i, f, this));

          if (!this->data_)
          {
            this->data_.set (r);
            continue;
          }
        }

        // filename
        //
        if (n.name () == L"filename" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< filename_type > r (
            filename_traits::create (i, f, this));

          if (!this->filename_)
          {
            this->filename_.set (r);
            continue;
          }
        }

        // supporti
        //
        if (n.name () == L"supporti" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< supporti_type > r (
            supporti_traits::create (i, f, this));

          if (!this->supporti_)
          {
            this->supporti_.set (r);
            continue;
          }
        }

        // argomenti
        //
        if (n.name () == L"argomenti" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< argomenti_type > r (
            argomenti_traits::create (i, f, this));

          if (!this->argomenti_)
          {
            this->argomenti_.set (r);
            continue;
          }
        }

        break;
      }

      if (!autori_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"autori",
          L"http://gestColl/biblioteca");
      }

      if (!numero_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"numero",
          L"http://gestColl/biblioteca");
      }
    }

    catalogo* catalogo::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class catalogo (*this, f, c);
    }

    catalogo& catalogo::
    operator= (const catalogo& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->autori_ = x.autori_;
        this->numero_ = x.numero_;
        this->data_ = x.data_;
        this->filename_ = x.filename_;
        this->supporti_ = x.supporti_;
        this->argomenti_ = x.argomenti_;
      }

      return *this;
    }

    catalogo::
    ~catalogo ()
    {
    }

    // biblioteca
    //

    biblioteca::
    biblioteca (const libri_type& libri,
                const cataloghi_type& cataloghi)
    : ::xml_schema::type (),
      libri_ (libri, this),
      cataloghi_ (cataloghi, this)
    {
    }

    biblioteca::
    biblioteca (::std::auto_ptr< libri_type > libri,
                ::std::auto_ptr< cataloghi_type > cataloghi)
    : ::xml_schema::type (),
      libri_ (libri, this),
      cataloghi_ (cataloghi, this)
    {
    }

    biblioteca::
    biblioteca (const biblioteca& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      libri_ (x.libri_, f, this),
      cataloghi_ (x.cataloghi_, f, this)
    {
    }

    biblioteca::
    biblioteca (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      libri_ (this),
      cataloghi_ (this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false, false);
        this->parse (p, f);
      }
    }

    void biblioteca::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // libri
        //
        if (n.name () == L"libri" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< libri_type > r (
            libri_traits::create (i, f, this));

          if (!libri_.present ())
          {
            this->libri_.set (r);
            continue;
          }
        }

        // cataloghi
        //
        if (n.name () == L"cataloghi" && n.namespace_ () == L"http://gestColl/biblioteca")
        {
          ::std::auto_ptr< cataloghi_type > r (
            cataloghi_traits::create (i, f, this));

          if (!cataloghi_.present ())
          {
            this->cataloghi_.set (r);
            continue;
          }
        }

        break;
      }

      if (!libri_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"libri",
          L"http://gestColl/biblioteca");
      }

      if (!cataloghi_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"cataloghi",
          L"http://gestColl/biblioteca");
      }
    }

    biblioteca* biblioteca::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class biblioteca (*this, f, c);
    }

    biblioteca& biblioteca::
    operator= (const biblioteca& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::type& > (*this) = x;
        this->libri_ = x.libri_;
        this->cataloghi_ = x.cataloghi_;
      }

      return *this;
    }

    biblioteca::
    ~biblioteca ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace gestColl
{
  namespace biblioteca
  {
    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (const ::std::wstring& u,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::std::auto_ptr< ::gestColl::biblioteca::biblioteca > (
        ::gestColl::biblioteca::biblioteca_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (const ::std::wstring& u,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      return ::std::auto_ptr< ::gestColl::biblioteca::biblioteca > (
        ::gestColl::biblioteca::biblioteca_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (const ::std::wstring& u,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      return ::std::auto_ptr< ::gestColl::biblioteca::biblioteca > (
        ::gestColl::biblioteca::biblioteca_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (::std::istream& is,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::gestColl::biblioteca::biblioteca_ (isrc, f, p);
    }

    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (::std::istream& is,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::gestColl::biblioteca::biblioteca_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (::std::istream& is,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::gestColl::biblioteca::biblioteca_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::gestColl::biblioteca::biblioteca_ (isrc, f, p);
    }

    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::gestColl::biblioteca::biblioteca_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (::std::istream& is,
                 const ::std::wstring& sid,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::gestColl::biblioteca::biblioteca_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (::xercesc::InputSource& i,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      return ::std::auto_ptr< ::gestColl::biblioteca::biblioteca > (
        ::gestColl::biblioteca::biblioteca_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (::xercesc::InputSource& i,
                 ::xml_schema::error_handler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      return ::std::auto_ptr< ::gestColl::biblioteca::biblioteca > (
        ::gestColl::biblioteca::biblioteca_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (::xercesc::InputSource& i,
                 ::xercesc::DOMErrorHandler& h,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      return ::std::auto_ptr< ::gestColl::biblioteca::biblioteca > (
        ::gestColl::biblioteca::biblioteca_ (
          d, f | ::xml_schema::flags::own_dom, p));
    }

    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (const ::xercesc::DOMDocument& doc,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
          static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

        return ::std::auto_ptr< ::gestColl::biblioteca::biblioteca > (
          ::gestColl::biblioteca::biblioteca_ (
            d, f | ::xml_schema::flags::own_dom, p));
      }

      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (n.name () == L"biblioteca" &&
          n.namespace_ () == L"http://gestColl/biblioteca")
      {
        ::std::auto_ptr< ::gestColl::biblioteca::biblioteca > r (
          ::xsd::cxx::tree::traits< ::gestColl::biblioteca::biblioteca, wchar_t >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"biblioteca",
        L"http://gestColl/biblioteca");
    }

    ::std::auto_ptr< ::gestColl::biblioteca::biblioteca >
    biblioteca_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
                 ::xml_schema::flags f,
                 const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == L"biblioteca" &&
          n.namespace_ () == L"http://gestColl/biblioteca")
      {
        ::std::auto_ptr< ::gestColl::biblioteca::biblioteca > r (
          ::xsd::cxx::tree::traits< ::gestColl::biblioteca::biblioteca, wchar_t >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"biblioteca",
        L"http://gestColl/biblioteca");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace gestColl
{
  namespace biblioteca
  {
    void
    operator<< (::xercesc::DOMElement& e, const autori& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // autore
      //
      for (autori::autore_const_iterator
           b (i.autore ().begin ()), n (i.autore ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"autore",
            L"http://gestColl/biblioteca",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const supporti& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // supporto
      //
      for (supporti::supporto_const_iterator
           b (i.supporto ().begin ()), n (i.supporto ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"supporto",
            L"http://gestColl/biblioteca",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const argomenti& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // argomento
      //
      for (argomenti::argomento_const_iterator
           b (i.argomento ().begin ()), n (i.argomento ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"argomento",
            L"http://gestColl/biblioteca",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const librotype& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // id
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"id",
            L"http://gestColl/biblioteca",
            e));

        s << i.id ();
      }

      // autori
      //
      if (i.autori ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"autori",
            L"http://gestColl/biblioteca",
            e));

        s << *i.autori ();
      }

      // titolo
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"titolo",
            L"http://gestColl/biblioteca",
            e));

        s << i.titolo ();
      }

      // supporti
      //
      if (i.supporti ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"supporti",
            L"http://gestColl/biblioteca",
            e));

        s << *i.supporti ();
      }

      // filename
      //
      if (i.filename ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"filename",
            L"http://gestColl/biblioteca",
            e));

        s << *i.filename ();
      }

      // argomenti
      //
      if (i.argomenti ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"argomenti",
            L"http://gestColl/biblioteca",
            e));

        s << *i.argomenti ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const libri& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // libro
      //
      for (libri::libro_const_iterator
           b (i.libro ().begin ()), n (i.libro ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"libro",
            L"http://gestColl/biblioteca",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const cataloghi& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // catalogo
      //
      for (cataloghi::catalogo_const_iterator
           b (i.catalogo ().begin ()), n (i.catalogo ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"catalogo",
            L"http://gestColl/biblioteca",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const catalogo& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // autori
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"autori",
            L"http://gestColl/biblioteca",
            e));

        s << i.autori ();
      }

      // numero
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"numero",
            L"http://gestColl/biblioteca",
            e));

        s << i.numero ();
      }

      // data
      //
      if (i.data ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"data",
            L"http://gestColl/biblioteca",
            e));

        s << *i.data ();
      }

      // filename
      //
      if (i.filename ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"filename",
            L"http://gestColl/biblioteca",
            e));

        s << *i.filename ();
      }

      // supporti
      //
      if (i.supporti ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"supporti",
            L"http://gestColl/biblioteca",
            e));

        s << *i.supporti ();
      }

      // argomenti
      //
      if (i.argomenti ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"argomenti",
            L"http://gestColl/biblioteca",
            e));

        s << *i.argomenti ();
      }
    }

    void
    biblioteca_ (::std::ostream& o,
                 const ::gestColl::biblioteca::biblioteca& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::gestColl::biblioteca::biblioteca_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    biblioteca_ (::std::ostream& o,
                 const ::gestColl::biblioteca::biblioteca& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::gestColl::biblioteca::biblioteca_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    biblioteca_ (::std::ostream& o,
                 const ::gestColl::biblioteca::biblioteca& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::gestColl::biblioteca::biblioteca_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    biblioteca_ (::xercesc::XMLFormatTarget& t,
                 const ::gestColl::biblioteca::biblioteca& s,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::gestColl::biblioteca::biblioteca_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    biblioteca_ (::xercesc::XMLFormatTarget& t,
                 const ::gestColl::biblioteca::biblioteca& s,
                 ::xml_schema::error_handler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::gestColl::biblioteca::biblioteca_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    biblioteca_ (::xercesc::XMLFormatTarget& t,
                 const ::gestColl::biblioteca::biblioteca& s,
                 ::xercesc::DOMErrorHandler& h,
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::wstring& e,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::gestColl::biblioteca::biblioteca_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    biblioteca_ (::xercesc::DOMDocument& d,
                 const ::gestColl::biblioteca::biblioteca& s,
                 ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (n.name () == L"biblioteca" &&
          n.namespace_ () == L"http://gestColl/biblioteca")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
          n.name (),
          n.namespace_ (),
          L"biblioteca",
          L"http://gestColl/biblioteca");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    biblioteca_ (const ::gestColl::biblioteca::biblioteca& s,
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< wchar_t > (
          L"biblioteca",
          L"http://gestColl/biblioteca",
          m, f));

      ::gestColl::biblioteca::biblioteca_ (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const biblioteca& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // libri
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"libri",
            L"http://gestColl/biblioteca",
            e));

        s << i.libri ();
      }

      // cataloghi
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"cataloghi",
            L"http://gestColl/biblioteca",
            e));

        s << i.cataloghi ();
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

