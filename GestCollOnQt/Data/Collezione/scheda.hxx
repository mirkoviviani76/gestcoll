// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from scheda.xsd.
 */

#ifndef XML_SCHEMA_SCHEDA_HXX
#define XML_SCHEMA_SCHEDA_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 3030000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_WCHAR
#define XSD_USE_WCHAR
#endif

#ifndef XSD_CXX_TREE_USE_WCHAR
#define XSD_CXX_TREE_USE_WCHAR
#endif

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char unsigned_byte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short short_;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short unsigned_short;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int int_;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int unsigned_int;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long long_;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long unsigned_long;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long non_positive_integer;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long non_negative_integer;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long positive_integer;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long negative_integer;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float float_;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double double_;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< wchar_t, simple_type > string;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< wchar_t, string > normalized_string;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< wchar_t, normalized_string > token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< wchar_t, token > name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< wchar_t, token > nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< wchar_t, simple_type, nmtoken > nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< wchar_t, name > ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< wchar_t, token > language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< wchar_t, ncname > id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< wchar_t, ncname, type > idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< wchar_t, simple_type, idref > idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< wchar_t, simple_type > uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< wchar_t, simple_type, uri, ncname > qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< wchar_t > buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< wchar_t, simple_type > base64_binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< wchar_t, simple_type > hex_binary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone time_zone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< wchar_t, simple_type > date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< wchar_t, simple_type > date_time;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< wchar_t, simple_type > duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< wchar_t, simple_type > gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< wchar_t, simple_type > gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< wchar_t, simple_type > gmonth_day;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< wchar_t, simple_type > gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< wchar_t, simple_type > gyear_month;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< wchar_t, simple_type > time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< wchar_t, ncname > entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< wchar_t, simple_type, entity > entities;


  // Namespace information and list stream. Used in
  // serialization functions.
  //
  /**
   * @brief Namespace serialization information.
   */
  typedef ::xsd::cxx::xml::dom::namespace_info< wchar_t > namespace_info;

  /**
   * @brief Namespace serialization information map.
   */
  typedef ::xsd::cxx::xml::dom::namespace_infomap< wchar_t > namespace_infomap;

  /**
   * @brief List serialization stream.
   */
  typedef ::xsd::cxx::tree::list_stream< wchar_t > list_stream;

  /**
   * @brief Serialization wrapper for the %double type.
   */
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;

  /**
   * @brief Serialization wrapper for the %decimal type.
   */
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;

  /**
   * @brief Simple type facet.
   */
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< wchar_t > properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< wchar_t > error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< wchar_t > diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< wchar_t > exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< wchar_t > bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< wchar_t > duplicate_id;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< wchar_t > parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< wchar_t > expected_element;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< wchar_t > unexpected_element;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< wchar_t > expected_attribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< wchar_t > unexpected_enumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< wchar_t > expected_text_content;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< wchar_t > no_prefix_mapping;

  /**
   * @brief Exception indicating a serialization failure.
   */
  typedef ::xsd::cxx::tree::serialization< wchar_t > serialization;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< wchar_t > error_handler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace gestColl
{
  namespace coins
  {
    class info;
    class ambiti;
    class ambito;
    class autorita;
    class zecca;
    class zecchiere;
    class legenda;
    class descrizioni;
    class misura;
    class nominale;
    class libro;
    class asta;
    class documentoAddizionale;
    class documentiAggiuntivi;
    class letteratura;
    class note;
    class posizione;
    class datiAcquisto;
    class datiFisici;
    class datiArtistici;
    class zecchieri;
    class stato;
    class moneta;
    class monete;
  }
}


#include <memory>    // std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace gestColl
{
  /**
   * @brief C++ namespace for the %http://gestColl/coins
   * schema namespace.
   */
  namespace coins
  {
    /**
     * @brief Class corresponding to the %info schema type.
     *
     * @nosubgrouping
     */
    class info: public ::xml_schema::type
    {
      public:
      /**
       * @name titolo
       *
       * @brief Accessor and modifier functions for the %titolo
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string titolo_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< titolo_type, wchar_t > titolo_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const titolo_type&
      titolo () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      titolo_type&
      titolo ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      titolo (const titolo_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      titolo (::std::auto_ptr< titolo_type > p);

      //@}

      /**
       * @name proprietario
       *
       * @brief Accessor and modifier functions for the %proprietario
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string proprietario_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< proprietario_type, wchar_t > proprietario_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const proprietario_type&
      proprietario () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      proprietario_type&
      proprietario ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      proprietario (const proprietario_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      proprietario (::std::auto_ptr< proprietario_type > p);

      //@}

      /**
       * @name inizio
       *
       * @brief Accessor and modifier functions for the %inizio
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::date inizio_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< inizio_type, wchar_t > inizio_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const inizio_type&
      inizio () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      inizio_type&
      inizio ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      inizio (const inizio_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      inizio (::std::auto_ptr< inizio_type > p);

      //@}

      /**
       * @name ambiti
       *
       * @brief Accessor and modifier functions for the %ambiti
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::ambiti ambiti_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ambiti_type, wchar_t > ambiti_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const ambiti_type&
      ambiti () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      ambiti_type&
      ambiti ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      ambiti (const ambiti_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      ambiti (::std::auto_ptr< ambiti_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      info (const titolo_type&,
            const proprietario_type&,
            const inizio_type&,
            const ambiti_type&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (auto_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      info (const titolo_type&,
            const proprietario_type&,
            const inizio_type&,
            ::std::auto_ptr< ambiti_type >&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      info (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      info (const info& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual info*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~info ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< titolo_type > titolo_;
      ::xsd::cxx::tree::one< proprietario_type > proprietario_;
      ::xsd::cxx::tree::one< inizio_type > inizio_;
      ::xsd::cxx::tree::one< ambiti_type > ambiti_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ambiti schema type.
     *
     * @nosubgrouping
     */
    class ambiti: public ::xml_schema::type
    {
      public:
      /**
       * @name ambito
       *
       * @brief Accessor and modifier functions for the %ambito
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::ambito ambito_type;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< ambito_type > ambito_sequence;

      /**
       * @brief Element iterator type.
       */
      typedef ambito_sequence::iterator ambito_iterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef ambito_sequence::const_iterator ambito_const_iterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ambito_type, wchar_t > ambito_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const ambito_sequence&
      ambito () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      ambito_sequence&
      ambito ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      ambito (const ambito_sequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ambiti ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ambiti (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ambiti (const ambiti& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ambiti*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ambiti ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ambito_sequence ambito_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %ambito schema type.
     *
     * @nosubgrouping
     */
    class ambito: public ::xml_schema::type
    {
      public:
      /**
       * @name titolo
       *
       * @brief Accessor and modifier functions for the %titolo
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string titolo_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< titolo_type, wchar_t > titolo_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const titolo_type&
      titolo () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      titolo_type&
      titolo ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      titolo (const titolo_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      titolo (::std::auto_ptr< titolo_type > p);

      //@}

      /**
       * @name icon
       *
       * @brief Accessor and modifier functions for the %icon
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string icon_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< icon_type > icon_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< icon_type, wchar_t > icon_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const icon_optional&
      icon () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      icon_optional&
      icon ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      icon (const icon_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      icon (const icon_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      icon (::std::auto_ptr< icon_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      ambito (const titolo_type&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      ambito (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      ambito (const ambito& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual ambito*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~ambito ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< titolo_type > titolo_;
      icon_optional icon_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %autorita schema type.
     *
     * @nosubgrouping
     */
    class autorita: public ::xml_schema::type
    {
      public:
      /**
       * @name nome
       *
       * @brief Accessor and modifier functions for the %nome
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string nome_type;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< nome_type > nome_sequence;

      /**
       * @brief Element iterator type.
       */
      typedef nome_sequence::iterator nome_iterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef nome_sequence::const_iterator nome_const_iterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< nome_type, wchar_t > nome_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const nome_sequence&
      nome () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      nome_sequence&
      nome ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      nome (const nome_sequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      autorita ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      autorita (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      autorita (const autorita& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual autorita*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~autorita ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      nome_sequence nome_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %zecca schema type.
     *
     * Tipo che definisce una zecca
     *
     * @nosubgrouping
     */
    class zecca: public ::xml_schema::type
    {
      public:
      /**
       * @name nome
       *
       * @brief Accessor and modifier functions for the %nome
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string nome_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< nome_type > nome_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< nome_type, wchar_t > nome_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const nome_optional&
      nome () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      nome_optional&
      nome ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      nome (const nome_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      nome (const nome_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      nome (::std::auto_ptr< nome_type > p);

      //@}

      /**
       * @name segno
       *
       * @brief Accessor and modifier functions for the %segno
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string segno_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< segno_type > segno_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< segno_type, wchar_t > segno_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const segno_optional&
      segno () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      segno_optional&
      segno ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      segno (const segno_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      segno (const segno_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      segno (::std::auto_ptr< segno_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      zecca ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      zecca (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      zecca (const zecca& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual zecca*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~zecca ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      nome_optional nome_;
      segno_optional segno_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %zecchiere schema type.
     *
     * Tipo che definisce uno zecchiere
     *
     * @nosubgrouping
     */
    class zecchiere: public ::xml_schema::type
    {
      public:
      /**
       * @name nome
       *
       * @brief Accessor and modifier functions for the %nome
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string nome_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< nome_type > nome_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< nome_type, wchar_t > nome_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const nome_optional&
      nome () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      nome_optional&
      nome ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      nome (const nome_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      nome (const nome_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      nome (::std::auto_ptr< nome_type > p);

      //@}

      /**
       * @name segno
       *
       * @brief Accessor and modifier functions for the %segno
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string segno_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< segno_type > segno_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< segno_type, wchar_t > segno_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const segno_optional&
      segno () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      segno_optional&
      segno ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      segno (const segno_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      segno (const segno_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      segno (::std::auto_ptr< segno_type > p);

      //@}

      /**
       * @name ruolo
       *
       * @brief Accessor and modifier functions for the %ruolo
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string ruolo_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ruolo_type > ruolo_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ruolo_type, wchar_t > ruolo_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ruolo_optional&
      ruolo () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ruolo_optional&
      ruolo ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      ruolo (const ruolo_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      ruolo (const ruolo_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      ruolo (::std::auto_ptr< ruolo_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      zecchiere ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      zecchiere (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      zecchiere (const zecchiere& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual zecchiere*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~zecchiere ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      nome_optional nome_;
      segno_optional segno_;
      ruolo_optional ruolo_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %legenda schema type.
     *
     * Tipo che definisce una legenda
     *
     * @nosubgrouping
     */
    class legenda: public ::xml_schema::type
    {
      public:
      /**
       * @name testo
       *
       * @brief Accessor and modifier functions for the %testo
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string testo_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< testo_type, wchar_t > testo_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const testo_type&
      testo () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      testo_type&
      testo ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      testo (const testo_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      testo (::std::auto_ptr< testo_type > p);

      //@}

      /**
       * @name scioglimento
       *
       * @brief Accessor and modifier functions for the %scioglimento
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string scioglimento_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< scioglimento_type > scioglimento_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< scioglimento_type, wchar_t > scioglimento_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const scioglimento_optional&
      scioglimento () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      scioglimento_optional&
      scioglimento ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      scioglimento (const scioglimento_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      scioglimento (const scioglimento_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      scioglimento (::std::auto_ptr< scioglimento_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      legenda (const testo_type&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      legenda (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      legenda (const legenda& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual legenda*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~legenda ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< testo_type > testo_;
      scioglimento_optional scioglimento_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %descrizioni schema type.
     *
     * Tipo che definisce una descrizione
     *
     * @nosubgrouping
     */
    class descrizioni: public ::xml_schema::type
    {
      public:
      /**
       * @name descrizione
       *
       * @brief Accessor and modifier functions for the %descrizione
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string descrizione_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< descrizione_type, wchar_t > descrizione_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const descrizione_type&
      descrizione () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      descrizione_type&
      descrizione ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      descrizione (const descrizione_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      descrizione (::std::auto_ptr< descrizione_type > p);

      //@}

      /**
       * @name legenda
       *
       * @brief Accessor and modifier functions for the %legenda
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::legenda legenda_type;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< legenda_type > legenda_sequence;

      /**
       * @brief Element iterator type.
       */
      typedef legenda_sequence::iterator legenda_iterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef legenda_sequence::const_iterator legenda_const_iterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< legenda_type, wchar_t > legenda_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const legenda_sequence&
      legenda () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      legenda_sequence&
      legenda ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      legenda (const legenda_sequence& s);

      //@}

      /**
       * @name fileImmagine
       *
       * @brief Accessor and modifier functions for the %fileImmagine
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string fileImmagine_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< fileImmagine_type > fileImmagine_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< fileImmagine_type, wchar_t > fileImmagine_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const fileImmagine_optional&
      fileImmagine () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      fileImmagine_optional&
      fileImmagine ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      fileImmagine (const fileImmagine_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      fileImmagine (const fileImmagine_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      fileImmagine (::std::auto_ptr< fileImmagine_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      descrizioni (const descrizione_type&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      descrizioni (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      descrizioni (const descrizioni& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual descrizioni*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~descrizioni ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< descrizione_type > descrizione_;
      legenda_sequence legenda_;
      fileImmagine_optional fileImmagine_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %misura schema type.
     *
     * Tipo che definisce una unita di misura e un valore (numerico)
     *
     * @nosubgrouping
     */
    class misura: public ::xml_schema::type
    {
      public:
      /**
       * @name unita
       *
       * @brief Accessor and modifier functions for the %unita
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string unita_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< unita_type, wchar_t > unita_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const unita_type&
      unita () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      unita_type&
      unita ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      unita (const unita_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      unita (::std::auto_ptr< unita_type > p);

      //@}

      /**
       * @name valore
       *
       * @brief Accessor and modifier functions for the %valore
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::decimal valore_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< valore_type, wchar_t, ::xsd::cxx::tree::schema_type::decimal > valore_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const valore_type&
      valore () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      valore_type&
      valore ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      valore (const valore_type& x);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      misura (const unita_type&,
              const valore_type&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      misura (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      misura (const misura& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual misura*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~misura ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< unita_type > unita_;
      ::xsd::cxx::tree::one< valore_type > valore_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %nominale schema type.
     *
     * Tipo che definisce un nominale
     *
     * @nosubgrouping
     */
    class nominale: public ::xml_schema::type
    {
      public:
      /**
       * @name valuta
       *
       * @brief Accessor and modifier functions for the %valuta
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string valuta_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< valuta_type, wchar_t > valuta_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const valuta_type&
      valuta () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      valuta_type&
      valuta ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      valuta (const valuta_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      valuta (::std::auto_ptr< valuta_type > p);

      //@}

      /**
       * @name valore
       *
       * @brief Accessor and modifier functions for the %valore
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string valore_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< valore_type, wchar_t > valore_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const valore_type&
      valore () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      valore_type&
      valore ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      valore (const valore_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      valore (::std::auto_ptr< valore_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      nominale (const valuta_type&,
                const valore_type&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      nominale (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      nominale (const nominale& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual nominale*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~nominale ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< valuta_type > valuta_;
      ::xsd::cxx::tree::one< valore_type > valore_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %libro schema type.
     *
     * Tipo che definisce un libro
     *
     * @nosubgrouping
     */
    class libro: public ::xml_schema::type
    {
      public:
      /**
       * @name sigla
       *
       * @brief Accessor and modifier functions for the %sigla
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string sigla_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< sigla_type, wchar_t > sigla_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const sigla_type&
      sigla () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      sigla_type&
      sigla ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      sigla (const sigla_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      sigla (::std::auto_ptr< sigla_type > p);

      //@}

      /**
       * @name numero
       *
       * @brief Accessor and modifier functions for the %numero
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string numero_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< numero_type, wchar_t > numero_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const numero_type&
      numero () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      numero_type&
      numero ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      numero (const numero_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      numero (::std::auto_ptr< numero_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      libro (const sigla_type&,
             const numero_type&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      libro (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      libro (const libro& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual libro*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~libro ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< sigla_type > sigla_;
      ::xsd::cxx::tree::one< numero_type > numero_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %asta schema type.
     *
     * Tipo che definisce un passaggio in asta
     *
     * @nosubgrouping
     */
    class asta: public ::xml_schema::type
    {
      public:
      /**
       * @name casa
       *
       * @brief Accessor and modifier functions for the %casa
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string casa_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< casa_type, wchar_t > casa_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const casa_type&
      casa () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      casa_type&
      casa ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      casa (const casa_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      casa (::std::auto_ptr< casa_type > p);

      //@}

      /**
       * @name idAsta
       *
       * @brief Accessor and modifier functions for the %idAsta
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string idAsta_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< idAsta_type, wchar_t > idAsta_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const idAsta_type&
      idAsta () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      idAsta_type&
      idAsta ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      idAsta (const idAsta_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      idAsta (::std::auto_ptr< idAsta_type > p);

      //@}

      /**
       * @name data
       *
       * @brief Accessor and modifier functions for the %data
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::date data_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< data_type, wchar_t > data_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const data_type&
      data () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      data_type&
      data ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      data (const data_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      data (::std::auto_ptr< data_type > p);

      //@}

      /**
       * @name lotto
       *
       * @brief Accessor and modifier functions for the %lotto
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string lotto_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< lotto_type, wchar_t > lotto_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const lotto_type&
      lotto () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      lotto_type&
      lotto ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      lotto (const lotto_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      lotto (::std::auto_ptr< lotto_type > p);

      //@}

      /**
       * @name stima
       *
       * @brief Accessor and modifier functions for the %stima
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::misura stima_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< stima_type, wchar_t > stima_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const stima_type&
      stima () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      stima_type&
      stima ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      stima (const stima_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      stima (::std::auto_ptr< stima_type > p);

      //@}

      /**
       * @name aggiudicazione
       *
       * @brief Accessor and modifier functions for the %aggiudicazione
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::misura aggiudicazione_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< aggiudicazione_type, wchar_t > aggiudicazione_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const aggiudicazione_type&
      aggiudicazione () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      aggiudicazione_type&
      aggiudicazione ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      aggiudicazione (const aggiudicazione_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      aggiudicazione (::std::auto_ptr< aggiudicazione_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      asta (const casa_type&,
            const idAsta_type&,
            const data_type&,
            const lotto_type&,
            const stima_type&,
            const aggiudicazione_type&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (auto_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      asta (const casa_type&,
            const idAsta_type&,
            const data_type&,
            const lotto_type&,
            ::std::auto_ptr< stima_type >&,
            ::std::auto_ptr< aggiudicazione_type >&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      asta (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      asta (const asta& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual asta*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~asta ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< casa_type > casa_;
      ::xsd::cxx::tree::one< idAsta_type > idAsta_;
      ::xsd::cxx::tree::one< data_type > data_;
      ::xsd::cxx::tree::one< lotto_type > lotto_;
      ::xsd::cxx::tree::one< stima_type > stima_;
      ::xsd::cxx::tree::one< aggiudicazione_type > aggiudicazione_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %documentoAddizionale schema type.
     *
     * Tipo che definisce un file addizionale
     *
     * @nosubgrouping
     */
    class documentoAddizionale: public ::xml_schema::type
    {
      public:
      /**
       * @name filename
       *
       * @brief Accessor and modifier functions for the %filename
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string filename_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< filename_type, wchar_t > filename_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const filename_type&
      filename () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      filename_type&
      filename ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      filename (const filename_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      filename (::std::auto_ptr< filename_type > p);

      //@}

      /**
       * @name descrizione
       *
       * @brief Accessor and modifier functions for the %descrizione
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string descrizione_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< descrizione_type, wchar_t > descrizione_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const descrizione_type&
      descrizione () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      descrizione_type&
      descrizione ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      descrizione (const descrizione_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      descrizione (::std::auto_ptr< descrizione_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      documentoAddizionale (const filename_type&,
                            const descrizione_type&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      documentoAddizionale (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      documentoAddizionale (const documentoAddizionale& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual documentoAddizionale*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~documentoAddizionale ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< filename_type > filename_;
      ::xsd::cxx::tree::one< descrizione_type > descrizione_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %documentiAggiuntivi schema type.
     *
     * @nosubgrouping
     */
    class documentiAggiuntivi: public ::xml_schema::type
    {
      public:
      /**
       * @name documento
       *
       * @brief Accessor and modifier functions for the %documento
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::documentoAddizionale documento_type;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< documento_type > documento_sequence;

      /**
       * @brief Element iterator type.
       */
      typedef documento_sequence::iterator documento_iterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef documento_sequence::const_iterator documento_const_iterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< documento_type, wchar_t > documento_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const documento_sequence&
      documento () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      documento_sequence&
      documento ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      documento (const documento_sequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      documentiAggiuntivi ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      documentiAggiuntivi (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      documentiAggiuntivi (const documentiAggiuntivi& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual documentiAggiuntivi*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~documentiAggiuntivi ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      documento_sequence documento_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %letteratura schema type.
     *
     * @nosubgrouping
     */
    class letteratura: public ::xml_schema::type
    {
      public:
      /**
       * @name libro
       *
       * @brief Accessor and modifier functions for the %libro
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::libro libro_type;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< libro_type > libro_sequence;

      /**
       * @brief Element iterator type.
       */
      typedef libro_sequence::iterator libro_iterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef libro_sequence::const_iterator libro_const_iterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< libro_type, wchar_t > libro_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const libro_sequence&
      libro () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      libro_sequence&
      libro ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      libro (const libro_sequence& s);

      //@}

      /**
       * @name asta
       *
       * @brief Accessor and modifier functions for the %asta
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::asta asta_type;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< asta_type > asta_sequence;

      /**
       * @brief Element iterator type.
       */
      typedef asta_sequence::iterator asta_iterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef asta_sequence::const_iterator asta_const_iterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< asta_type, wchar_t > asta_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const asta_sequence&
      asta () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      asta_sequence&
      asta ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      asta (const asta_sequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      letteratura ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      letteratura (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      letteratura (const letteratura& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual letteratura*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~letteratura ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      libro_sequence libro_;
      asta_sequence asta_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %note schema type.
     *
     * @nosubgrouping
     */
    class note: public ::xml_schema::type
    {
      public:
      /**
       * @name nota
       *
       * @brief Accessor and modifier functions for the %nota
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string nota_type;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< nota_type > nota_sequence;

      /**
       * @brief Element iterator type.
       */
      typedef nota_sequence::iterator nota_iterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef nota_sequence::const_iterator nota_const_iterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< nota_type, wchar_t > nota_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const nota_sequence&
      nota () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      nota_sequence&
      nota ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      nota (const nota_sequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      note ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      note (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      note (const note& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual note*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~note ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      nota_sequence nota_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %posizione schema type.
     *
     * @nosubgrouping
     */
    class posizione: public ::xml_schema::type
    {
      public:
      /**
       * @name contenitore
       *
       * @brief Accessor and modifier functions for the %contenitore
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::integer contenitore_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< contenitore_type, wchar_t > contenitore_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const contenitore_type&
      contenitore () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      contenitore_type&
      contenitore ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      contenitore (const contenitore_type& x);

      //@}

      /**
       * @name vassoio
       *
       * @brief Accessor and modifier functions for the %vassoio
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::integer vassoio_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< vassoio_type, wchar_t > vassoio_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const vassoio_type&
      vassoio () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      vassoio_type&
      vassoio ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      vassoio (const vassoio_type& x);

      //@}

      /**
       * @name riga
       *
       * @brief Accessor and modifier functions for the %riga
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::integer riga_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< riga_type, wchar_t > riga_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const riga_type&
      riga () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      riga_type&
      riga ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      riga (const riga_type& x);

      //@}

      /**
       * @name colonna
       *
       * @brief Accessor and modifier functions for the %colonna
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::integer colonna_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< colonna_type, wchar_t > colonna_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const colonna_type&
      colonna () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      colonna_type&
      colonna ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      colonna (const colonna_type& x);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      posizione (const contenitore_type&,
                 const vassoio_type&,
                 const riga_type&,
                 const colonna_type&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      posizione (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      posizione (const posizione& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual posizione*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~posizione ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< contenitore_type > contenitore_;
      ::xsd::cxx::tree::one< vassoio_type > vassoio_;
      ::xsd::cxx::tree::one< riga_type > riga_;
      ::xsd::cxx::tree::one< colonna_type > colonna_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %datiAcquisto schema type.
     *
     * @nosubgrouping
     */
    class datiAcquisto: public ::xml_schema::type
    {
      public:
      /**
       * @name luogo
       *
       * @brief Accessor and modifier functions for the %luogo
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string luogo_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< luogo_type, wchar_t > luogo_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const luogo_type&
      luogo () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      luogo_type&
      luogo ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      luogo (const luogo_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      luogo (::std::auto_ptr< luogo_type > p);

      //@}

      /**
       * @name data
       *
       * @brief Accessor and modifier functions for the %data
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::date data_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< data_type, wchar_t > data_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const data_type&
      data () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      data_type&
      data ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      data (const data_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      data (::std::auto_ptr< data_type > p);

      //@}

      /**
       * @name prezzo
       *
       * @brief Accessor and modifier functions for the %prezzo
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::misura prezzo_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< prezzo_type, wchar_t > prezzo_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const prezzo_type&
      prezzo () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      prezzo_type&
      prezzo ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      prezzo (const prezzo_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      prezzo (::std::auto_ptr< prezzo_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      datiAcquisto (const luogo_type&,
                    const data_type&,
                    const prezzo_type&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (auto_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      datiAcquisto (const luogo_type&,
                    const data_type&,
                    ::std::auto_ptr< prezzo_type >&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      datiAcquisto (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      datiAcquisto (const datiAcquisto& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual datiAcquisto*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~datiAcquisto ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< luogo_type > luogo_;
      ::xsd::cxx::tree::one< data_type > data_;
      ::xsd::cxx::tree::one< prezzo_type > prezzo_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %datiFisici schema type.
     *
     * @nosubgrouping
     */
    class datiFisici: public ::xml_schema::type
    {
      public:
      /**
       * @name peso
       *
       * @brief Accessor and modifier functions for the %peso
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::misura peso_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< peso_type, wchar_t > peso_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const peso_type&
      peso () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      peso_type&
      peso ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      peso (const peso_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      peso (::std::auto_ptr< peso_type > p);

      //@}

      /**
       * @name diametro
       *
       * @brief Accessor and modifier functions for the %diametro
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::misura diametro_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< diametro_type, wchar_t > diametro_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const diametro_type&
      diametro () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      diametro_type&
      diametro ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      diametro (const diametro_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      diametro (::std::auto_ptr< diametro_type > p);

      //@}

      /**
       * @name forma
       *
       * @brief Accessor and modifier functions for the %forma
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string forma_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< forma_type, wchar_t > forma_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const forma_type&
      forma () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      forma_type&
      forma ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      forma (const forma_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      forma (::std::auto_ptr< forma_type > p);

      //@}

      /**
       * @name metallo
       *
       * @brief Accessor and modifier functions for the %metallo
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string metallo_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< metallo_type, wchar_t > metallo_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const metallo_type&
      metallo () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      metallo_type&
      metallo ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      metallo (const metallo_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      metallo (::std::auto_ptr< metallo_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      datiFisici (const peso_type&,
                  const diametro_type&,
                  const forma_type&,
                  const metallo_type&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (auto_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      datiFisici (::std::auto_ptr< peso_type >&,
                  ::std::auto_ptr< diametro_type >&,
                  const forma_type&,
                  const metallo_type&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      datiFisici (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      datiFisici (const datiFisici& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual datiFisici*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~datiFisici ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< peso_type > peso_;
      ::xsd::cxx::tree::one< diametro_type > diametro_;
      ::xsd::cxx::tree::one< forma_type > forma_;
      ::xsd::cxx::tree::one< metallo_type > metallo_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %datiArtistici schema type.
     *
     * @nosubgrouping
     */
    class datiArtistici: public ::xml_schema::type
    {
      public:
      /**
       * @name dritto
       *
       * @brief Accessor and modifier functions for the %dritto
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::descrizioni dritto_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< dritto_type, wchar_t > dritto_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const dritto_type&
      dritto () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      dritto_type&
      dritto ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      dritto (const dritto_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      dritto (::std::auto_ptr< dritto_type > p);

      //@}

      /**
       * @name rovescio
       *
       * @brief Accessor and modifier functions for the %rovescio
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::descrizioni rovescio_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< rovescio_type, wchar_t > rovescio_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const rovescio_type&
      rovescio () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      rovescio_type&
      rovescio ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      rovescio (const rovescio_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      rovescio (::std::auto_ptr< rovescio_type > p);

      //@}

      /**
       * @name taglio
       *
       * @brief Accessor and modifier functions for the %taglio
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::descrizioni taglio_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< taglio_type, wchar_t > taglio_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const taglio_type&
      taglio () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      taglio_type&
      taglio ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      taglio (const taglio_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      taglio (::std::auto_ptr< taglio_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      datiArtistici (const dritto_type&,
                     const rovescio_type&,
                     const taglio_type&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (auto_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      datiArtistici (::std::auto_ptr< dritto_type >&,
                     ::std::auto_ptr< rovescio_type >&,
                     ::std::auto_ptr< taglio_type >&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      datiArtistici (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      datiArtistici (const datiArtistici& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual datiArtistici*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~datiArtistici ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< dritto_type > dritto_;
      ::xsd::cxx::tree::one< rovescio_type > rovescio_;
      ::xsd::cxx::tree::one< taglio_type > taglio_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %zecchieri schema type.
     *
     * @nosubgrouping
     */
    class zecchieri: public ::xml_schema::type
    {
      public:
      /**
       * @name zecchiere
       *
       * @brief Accessor and modifier functions for the %zecchiere
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::zecchiere zecchiere_type;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< zecchiere_type > zecchiere_sequence;

      /**
       * @brief Element iterator type.
       */
      typedef zecchiere_sequence::iterator zecchiere_iterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef zecchiere_sequence::const_iterator zecchiere_const_iterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< zecchiere_type, wchar_t > zecchiere_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const zecchiere_sequence&
      zecchiere () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      zecchiere_sequence&
      zecchiere ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      zecchiere (const zecchiere_sequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      zecchieri ();

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      zecchieri (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      zecchieri (const zecchieri& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual zecchieri*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~zecchieri ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      zecchiere_sequence zecchiere_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %stato schema type.
     *
     * @nosubgrouping
     */
    class stato: public ::xml_schema::type
    {
      public:
      /**
       * @name colore
       *
       * @brief Accessor and modifier functions for the %colore
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string colore_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< colore_type, wchar_t > colore_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const colore_type&
      colore () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      colore_type&
      colore ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      colore (const colore_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      colore (::std::auto_ptr< colore_type > p);

      //@}

      /**
       * @name motivo
       *
       * @brief Accessor and modifier functions for the %motivo
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string motivo_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< motivo_type, wchar_t > motivo_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const motivo_type&
      motivo () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      motivo_type&
      motivo ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      motivo (const motivo_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      motivo (::std::auto_ptr< motivo_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      stato (const colore_type&,
             const motivo_type&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      stato (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      stato (const stato& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual stato*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~stato ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< colore_type > colore_;
      ::xsd::cxx::tree::one< motivo_type > motivo_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %moneta schema type.
     *
     * Descrizione di una moneta
     *
     * @nosubgrouping
     */
    class moneta: public ::xml_schema::type
    {
      public:
      /**
       * @name ambiti
       *
       * @brief Accessor and modifier functions for the %ambiti
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::ambiti ambiti_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< ambiti_type > ambiti_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< ambiti_type, wchar_t > ambiti_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const ambiti_optional&
      ambiti () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      ambiti_optional&
      ambiti ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      ambiti (const ambiti_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      ambiti (const ambiti_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      ambiti (::std::auto_ptr< ambiti_type > p);

      //@}

      /**
       * @name paese
       *
       * @brief Accessor and modifier functions for the %paese
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string paese_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< paese_type, wchar_t > paese_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const paese_type&
      paese () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      paese_type&
      paese ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      paese (const paese_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      paese (::std::auto_ptr< paese_type > p);

      //@}

      /**
       * @name autorita
       *
       * @brief Accessor and modifier functions for the %autorita
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::autorita autorita_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< autorita_type, wchar_t > autorita_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const autorita_type&
      autorita () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      autorita_type&
      autorita ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      autorita (const autorita_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      autorita (::std::auto_ptr< autorita_type > p);

      //@}

      /**
       * @name anno
       *
       * @brief Accessor and modifier functions for the %anno
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string anno_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< anno_type > anno_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< anno_type, wchar_t > anno_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const anno_optional&
      anno () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      anno_optional&
      anno ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      anno (const anno_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      anno (const anno_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      anno (::std::auto_ptr< anno_type > p);

      //@}

      /**
       * @name nominale
       *
       * @brief Accessor and modifier functions for the %nominale
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::nominale nominale_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< nominale_type, wchar_t > nominale_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const nominale_type&
      nominale () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      nominale_type&
      nominale ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      nominale (const nominale_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      nominale (::std::auto_ptr< nominale_type > p);

      //@}

      /**
       * @name zecca
       *
       * @brief Accessor and modifier functions for the %zecca
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::zecca zecca_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< zecca_type > zecca_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< zecca_type, wchar_t > zecca_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const zecca_optional&
      zecca () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      zecca_optional&
      zecca ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      zecca (const zecca_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      zecca (const zecca_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      zecca (::std::auto_ptr< zecca_type > p);

      //@}

      /**
       * @name zecchieri
       *
       * @brief Accessor and modifier functions for the %zecchieri
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::zecchieri zecchieri_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< zecchieri_type > zecchieri_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< zecchieri_type, wchar_t > zecchieri_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const zecchieri_optional&
      zecchieri () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      zecchieri_optional&
      zecchieri ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      zecchieri (const zecchieri_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      zecchieri (const zecchieri_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      zecchieri (::std::auto_ptr< zecchieri_type > p);

      //@}

      /**
       * @name datiArtistici
       *
       * @brief Accessor and modifier functions for the %datiArtistici
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::datiArtistici datiArtistici_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< datiArtistici_type, wchar_t > datiArtistici_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const datiArtistici_type&
      datiArtistici () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      datiArtistici_type&
      datiArtistici ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      datiArtistici (const datiArtistici_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      datiArtistici (::std::auto_ptr< datiArtistici_type > p);

      //@}

      /**
       * @name datiFisici
       *
       * @brief Accessor and modifier functions for the %datiFisici
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::datiFisici datiFisici_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< datiFisici_type, wchar_t > datiFisici_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const datiFisici_type&
      datiFisici () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      datiFisici_type&
      datiFisici ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      datiFisici (const datiFisici_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      datiFisici (::std::auto_ptr< datiFisici_type > p);

      //@}

      /**
       * @name datiAcquisto
       *
       * @brief Accessor and modifier functions for the %datiAcquisto
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::datiAcquisto datiAcquisto_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< datiAcquisto_type, wchar_t > datiAcquisto_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const datiAcquisto_type&
      datiAcquisto () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      datiAcquisto_type&
      datiAcquisto ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      datiAcquisto (const datiAcquisto_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      datiAcquisto (::std::auto_ptr< datiAcquisto_type > p);

      //@}

      /**
       * @name posizione
       *
       * @brief Accessor and modifier functions for the %posizione
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::posizione posizione_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< posizione_type > posizione_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< posizione_type, wchar_t > posizione_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const posizione_optional&
      posizione () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      posizione_optional&
      posizione ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      posizione (const posizione_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      posizione (const posizione_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      posizione (::std::auto_ptr< posizione_type > p);

      //@}

      /**
       * @name grado
       *
       * @brief Accessor and modifier functions for the %grado
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::string grado_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< grado_type > grado_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< grado_type, wchar_t > grado_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const grado_optional&
      grado () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      grado_optional&
      grado ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      grado (const grado_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      grado (const grado_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      grado (::std::auto_ptr< grado_type > p);

      //@}

      /**
       * @name note
       *
       * @brief Accessor and modifier functions for the %note
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::note note_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< note_type > note_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< note_type, wchar_t > note_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const note_optional&
      note () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      note_optional&
      note ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      note (const note_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      note (const note_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      note (::std::auto_ptr< note_type > p);

      //@}

      /**
       * @name letteratura
       *
       * @brief Accessor and modifier functions for the %letteratura
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::letteratura letteratura_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< letteratura_type > letteratura_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< letteratura_type, wchar_t > letteratura_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const letteratura_optional&
      letteratura () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      letteratura_optional&
      letteratura ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      letteratura (const letteratura_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      letteratura (const letteratura_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      letteratura (::std::auto_ptr< letteratura_type > p);

      //@}

      /**
       * @name itemAddizionali
       *
       * @brief Accessor and modifier functions for the %itemAddizionali
       * optional element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::documentiAggiuntivi itemAddizionali_type;

      /**
       * @brief Element optional container type.
       */
      typedef ::xsd::cxx::tree::optional< itemAddizionali_type > itemAddizionali_optional;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< itemAddizionali_type, wchar_t > itemAddizionali_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * container.
       *
       * @return A constant reference to the optional container.
       */
      const itemAddizionali_optional&
      itemAddizionali () const;

      /**
       * @brief Return a read-write reference to the element container.
       *
       * @return A reference to the optional container.
       */
      itemAddizionali_optional&
      itemAddizionali ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      itemAddizionali (const itemAddizionali_type& x);

      /**
       * @brief Set the element value.
       *
       * @param x An optional container with the new value to set.
       *
       * If the value is present in @a x then this function makes a copy 
       * of this value and sets it as the new value of the element.
       * Otherwise the element container is set the 'not present' state.
       */
      void
      itemAddizionali (const itemAddizionali_optional& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly instead
       * of making a copy.
       */
      void
      itemAddizionali (::std::auto_ptr< itemAddizionali_type > p);

      //@}

      /**
       * @name stato
       *
       * @brief Accessor and modifier functions for the %stato
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::stato stato_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< stato_type, wchar_t > stato_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const stato_type&
      stato () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      stato_type&
      stato ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      stato (const stato_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      stato (::std::auto_ptr< stato_type > p);

      //@}

      /**
       * @name revisione
       *
       * @brief Accessor and modifier functions for the %revisione
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::xml_schema::date_time revisione_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< revisione_type, wchar_t > revisione_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const revisione_type&
      revisione () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      revisione_type&
      revisione ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      revisione (const revisione_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      revisione (::std::auto_ptr< revisione_type > p);

      //@}

      /**
       * @name id
       *
       * @brief Accessor and modifier functions for the %id
       * required attribute.
       */
      //@{

      /**
       * @brief Attribute type.
       */
      typedef ::xml_schema::string id_type;

      /**
       * @brief Attribute traits type.
       */
      typedef ::xsd::cxx::tree::traits< id_type, wchar_t > id_traits;

      /**
       * @brief Return a read-only (constant) reference to the attribute.
       *
       * @return A constant reference to the attribute.
       */
      const id_type&
      id () const;

      /**
       * @brief Return a read-write reference to the attribute.
       *
       * @return A reference to the attribute.
       */
      id_type&
      id ();

      /**
       * @brief Set the attribute value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the attribute.
       */
      void
      id (const id_type& x);

      /**
       * @brief Set the attribute value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      id (::std::auto_ptr< id_type > p);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      moneta (const paese_type&,
              const autorita_type&,
              const nominale_type&,
              const datiArtistici_type&,
              const datiFisici_type&,
              const datiAcquisto_type&,
              const stato_type&,
              const revisione_type&,
              const id_type&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (auto_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      moneta (const paese_type&,
              ::std::auto_ptr< autorita_type >&,
              ::std::auto_ptr< nominale_type >&,
              ::std::auto_ptr< datiArtistici_type >&,
              ::std::auto_ptr< datiFisici_type >&,
              ::std::auto_ptr< datiAcquisto_type >&,
              ::std::auto_ptr< stato_type >&,
              const revisione_type&,
              const id_type&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      moneta (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      moneta (const moneta& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual moneta*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~moneta ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ambiti_optional ambiti_;
      ::xsd::cxx::tree::one< paese_type > paese_;
      ::xsd::cxx::tree::one< autorita_type > autorita_;
      anno_optional anno_;
      ::xsd::cxx::tree::one< nominale_type > nominale_;
      zecca_optional zecca_;
      zecchieri_optional zecchieri_;
      ::xsd::cxx::tree::one< datiArtistici_type > datiArtistici_;
      ::xsd::cxx::tree::one< datiFisici_type > datiFisici_;
      ::xsd::cxx::tree::one< datiAcquisto_type > datiAcquisto_;
      posizione_optional posizione_;
      grado_optional grado_;
      note_optional note_;
      letteratura_optional letteratura_;
      itemAddizionali_optional itemAddizionali_;
      ::xsd::cxx::tree::one< stato_type > stato_;
      ::xsd::cxx::tree::one< revisione_type > revisione_;
      ::xsd::cxx::tree::one< id_type > id_;

      //@endcond
    };

    /**
     * @brief Class corresponding to the %monete schema type.
     *
     * @nosubgrouping
     */
    class monete: public ::xml_schema::type
    {
      public:
      /**
       * @name info
       *
       * @brief Accessor and modifier functions for the %info
       * required element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::info info_type;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< info_type, wchar_t > info_traits;

      /**
       * @brief Return a read-only (constant) reference to the element.
       *
       * @return A constant reference to the element.
       */
      const info_type&
      info () const;

      /**
       * @brief Return a read-write reference to the element.
       *
       * @return A reference to the element.
       */
      info_type&
      info ();

      /**
       * @brief Set the element value.
       *
       * @param x A new value to set.
       *
       * This function makes a copy of its argument and sets it as
       * the new value of the element.
       */
      void
      info (const info_type& x);

      /**
       * @brief Set the element value without copying.
       *
       * @param p A new value to use.
       *
       * This function will try to use the passed value directly
       * instead of making a copy.
       */
      void
      info (::std::auto_ptr< info_type > p);

      //@}

      /**
       * @name moneta
       *
       * @brief Accessor and modifier functions for the %moneta
       * sequence element.
       */
      //@{

      /**
       * @brief Element type.
       */
      typedef ::gestColl::coins::moneta moneta_type;

      /**
       * @brief Element sequence container type.
       */
      typedef ::xsd::cxx::tree::sequence< moneta_type > moneta_sequence;

      /**
       * @brief Element iterator type.
       */
      typedef moneta_sequence::iterator moneta_iterator;

      /**
       * @brief Element constant iterator type.
       */
      typedef moneta_sequence::const_iterator moneta_const_iterator;

      /**
       * @brief Element traits type.
       */
      typedef ::xsd::cxx::tree::traits< moneta_type, wchar_t > moneta_traits;

      /**
       * @brief Return a read-only (constant) reference to the element
       * sequence.
       *
       * @return A constant reference to the sequence container.
       */
      const moneta_sequence&
      moneta () const;

      /**
       * @brief Return a read-write reference to the element sequence.
       *
       * @return A reference to the sequence container.
       */
      moneta_sequence&
      moneta ();

      /**
       * @brief Copy elements from a given sequence.
       *
       * @param s A sequence to copy elements from.
       *
       * For each element in @a s this function makes a copy and adds it 
       * to the sequence. Note that this operation completely changes the 
       * sequence and all old elements will be lost.
       */
      void
      moneta (const moneta_sequence& s);

      //@}

      /**
       * @name Constructors
       */
      //@{

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes.
       */
      monete (const info_type&);

      /**
       * @brief Create an instance from the ultimate base and
       * initializers for required elements and attributes
       * (auto_ptr version).
       *
       * This constructor will try to use the passed values directly
       * instead of making copies.
       */
      monete (::std::auto_ptr< info_type >&);

      /**
       * @brief Create an instance from a DOM element.
       *
       * @param e A DOM element to extract the data from.
       * @param f Flags to create the new instance with.
       * @param c A pointer to the object that will contain the new
       * instance.
       */
      monete (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      /**
       * @brief Copy constructor.
       *
       * @param x An instance to make a copy of.
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       *
       * For polymorphic object models use the @c _clone function instead.
       */
      monete (const monete& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      /**
       * @brief Copy the instance polymorphically.
       *
       * @param f Flags to create the copy with.
       * @param c A pointer to the object that will contain the copy.
       * @return A pointer to the dynamically allocated copy.
       *
       * This function ensures that the dynamic type of the instance is
       * used for copying and should be used for polymorphic object
       * models instead of the copy constructor.
       */
      virtual monete*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      //@}

      /**
       * @brief Destructor.
       */
      virtual 
      ~monete ();

      // Implementation.
      //

      //@cond

      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< wchar_t >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< info_type > info_;
      moneta_sequence moneta_;

      //@endcond
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace gestColl
{
  namespace coins
  {
    /**
     * @name Parsing functions for the %monete document root.
     *
     * La collezione
     */
    //@{

    /**
     * @brief Parse a URI or a local file.
     *
     * @param uri A URI or a local file name.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function uses exceptions to report parsing errors.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (const ::std::wstring& uri,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    /**
     * @brief Parse a URI or a local file with an error handler.
     *
     * @param uri A URI or a local file name.
     * @param eh An error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (const ::std::wstring& uri,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    /**
     * @brief Parse a URI or a local file with a Xerces-C++ DOM error
     * handler.
     *
     * @param uri A URI or a local file name.
     * @param eh A Xerces-C++ DOM error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (const ::std::wstring& uri,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    /**
     * @brief Parse a standard input stream.
     *
     * @param is A standrad input stream.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function uses exceptions to report parsing errors.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::std::istream& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    /**
     * @brief Parse a standard input stream with an error handler.
     *
     * @param is A standrad input stream.
     * @param eh An error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::std::istream& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    /**
     * @brief Parse a standard input stream with a Xerces-C++ DOM error
     * handler.
     *
     * @param is A standrad input stream.
     * @param eh A Xerces-C++ DOM error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    /**
     * @brief Parse a standard input stream with a resource id.
     *
     * @param is A standrad input stream.
     * @param id A resource id.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * The resource id is used to identify the document being parsed in
     * diagnostics as well as to resolve relative paths.
     *
     * This function uses exceptions to report parsing errors.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::std::istream& is,
             const ::std::wstring& id,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    /**
     * @brief Parse a standard input stream with a resource id and an
     * error handler.
     *
     * @param is A standrad input stream.
     * @param id A resource id.
     * @param eh An error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * The resource id is used to identify the document being parsed in
     * diagnostics as well as to resolve relative paths.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::std::istream& is,
             const ::std::wstring& id,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    /**
     * @brief Parse a standard input stream with a resource id and a
     * Xerces-C++ DOM error handler.
     *
     * @param is A standrad input stream.
     * @param id A resource id.
     * @param eh A Xerces-C++ DOM error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * The resource id is used to identify the document being parsed in
     * diagnostics as well as to resolve relative paths.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::std::istream& is,
             const ::std::wstring& id,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    /**
     * @brief Parse a Xerces-C++ input source.
     *
     * @param is A Xerces-C++ input source.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function uses exceptions to report parsing errors.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::xercesc::InputSource& is,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    /**
     * @brief Parse a Xerces-C++ input source with an error handler.
     *
     * @param is A Xerces-C++ input source.
     * @param eh An error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::xercesc::InputSource& is,
             ::xml_schema::error_handler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    /**
     * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
     * error handler.
     *
     * @param is A Xerces-C++ input source.
     * @param eh A Xerces-C++ DOM error handler.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function reports parsing errors by calling the error handler.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::xercesc::InputSource& is,
             ::xercesc::DOMErrorHandler& eh,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    /**
     * @brief Parse a Xerces-C++ DOM document.
     *
     * @param d A Xerces-C++ DOM document.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    /**
     * @brief Parse a Xerces-C++ DOM document.
     *
     * @param d A pointer to the Xerces-C++ DOM document.
     * @param f Parsing flags.
     * @param p Parsing properties. 
     * @return A pointer to the root of the object model.
     *
     * This function is normally used together with the keep_dom and
     * own_dom parsing flags to assign ownership of the DOM document
     * to the object model.
     */
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f = 0,
             const ::xml_schema::properties& p = ::xml_schema::properties ());

    //@}
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace gestColl
{
  namespace coins
  {
    void
    operator<< (::xercesc::DOMElement&, const info&);

    void
    operator<< (::xercesc::DOMElement&, const ambiti&);

    void
    operator<< (::xercesc::DOMElement&, const ambito&);

    void
    operator<< (::xercesc::DOMElement&, const autorita&);

    void
    operator<< (::xercesc::DOMElement&, const zecca&);

    void
    operator<< (::xercesc::DOMElement&, const zecchiere&);

    void
    operator<< (::xercesc::DOMElement&, const legenda&);

    void
    operator<< (::xercesc::DOMElement&, const descrizioni&);

    void
    operator<< (::xercesc::DOMElement&, const misura&);

    void
    operator<< (::xercesc::DOMElement&, const nominale&);

    void
    operator<< (::xercesc::DOMElement&, const libro&);

    void
    operator<< (::xercesc::DOMElement&, const asta&);

    void
    operator<< (::xercesc::DOMElement&, const documentoAddizionale&);

    void
    operator<< (::xercesc::DOMElement&, const documentiAggiuntivi&);

    void
    operator<< (::xercesc::DOMElement&, const letteratura&);

    void
    operator<< (::xercesc::DOMElement&, const note&);

    void
    operator<< (::xercesc::DOMElement&, const posizione&);

    void
    operator<< (::xercesc::DOMElement&, const datiAcquisto&);

    void
    operator<< (::xercesc::DOMElement&, const datiFisici&);

    void
    operator<< (::xercesc::DOMElement&, const datiArtistici&);

    void
    operator<< (::xercesc::DOMElement&, const zecchieri&);

    void
    operator<< (::xercesc::DOMElement&, const stato&);

    void
    operator<< (::xercesc::DOMElement&, const moneta&);

    /**
     * @name Serialization functions for the %monete document root.
     *
     * La collezione
     */
    //@{

    /**
     * @brief Serialize to a standard output stream.
     *
     * @param os A standrad output stream.
     * @param x An object model to serialize.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function uses exceptions to report serialization errors.
     */
    void
    monete_ (::std::ostream& os,
             const ::gestColl::coins::monete& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    /**
     * @brief Serialize to a standard output stream with an error handler.
     *
     * @param os A standrad output stream.
     * @param x An object model to serialize.
     * @param eh An error handler.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function reports serialization errors by calling the error
     * handler.
     */
    void
    monete_ (::std::ostream& os,
             const ::gestColl::coins::monete& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    /**
     * @brief Serialize to a standard output stream with a Xerces-C++ DOM
     * error handler.
     *
     * @param os A standrad output stream.
     * @param x An object model to serialize.
     * @param eh A Xerces-C++ DOM error handler.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function reports serialization errors by calling the error
     * handler.
     */
    void
    monete_ (::std::ostream& os,
             const ::gestColl::coins::monete& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    /**
     * @brief Serialize to a Xerces-C++ XML format target.
     *
     * @param ft A Xerces-C++ XML format target.
     * @param x An object model to serialize.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function uses exceptions to report serialization errors.
     */
    void
    monete_ (::xercesc::XMLFormatTarget& ft,
             const ::gestColl::coins::monete& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    /**
     * @brief Serialize to a Xerces-C++ XML format target with an error
     * handler.
     *
     * @param ft A Xerces-C++ XML format target.
     * @param x An object model to serialize.
     * @param eh An error handler.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function reports serialization errors by calling the error
     * handler.
     */
    void
    monete_ (::xercesc::XMLFormatTarget& ft,
             const ::gestColl::coins::monete& x, 
             ::xml_schema::error_handler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    /**
     * @brief Serialize to a Xerces-C++ XML format target with a
     * Xerces-C++ DOM error handler.
     *
     * @param ft A Xerces-C++ XML format target.
     * @param x An object model to serialize.
     * @param eh A Xerces-C++ DOM error handler.
     * @param m A namespace information map.
     * @param e A character encoding to produce XML in.
     * @param f Serialization flags.
     *
     * This function reports serialization errors by calling the error
     * handler.
     */
    void
    monete_ (::xercesc::XMLFormatTarget& ft,
             const ::gestColl::coins::monete& x, 
             ::xercesc::DOMErrorHandler& eh,
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             const ::std::wstring& e = L"UTF-8",
             ::xml_schema::flags f = 0);

    /**
     * @brief Serialize to an existing Xerces-C++ DOM document.
     *
     * @param d A Xerces-C++ DOM document.
     * @param x An object model to serialize.
     * @param f Serialization flags.
     *
     * Note that it is your responsibility to create the DOM document
     * with the correct root element as well as set the necessary
     * namespace mapping attributes.
     */
    void
    monete_ (::xercesc::DOMDocument& d,
             const ::gestColl::coins::monete& x,
             ::xml_schema::flags f = 0);

    /**
     * @brief Serialize to a new Xerces-C++ DOM document.
     *
     * @param x An object model to serialize.
     * @param m A namespace information map.
     * @param f Serialization flags.
     * @return A pointer to the new Xerces-C++ DOM document.
     */
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    monete_ (const ::gestColl::coins::monete& x, 
             const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
             ::xml_schema::flags f = 0);

    //@}

    void
    operator<< (::xercesc::DOMElement&, const monete&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // XML_SCHEMA_SCHEDA_HXX
