// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "scheda.hxx"

namespace gestColl
{
  namespace coins
  {
    // info
    // 

    const info::titolo_type& info::
    titolo () const
    {
      return this->titolo_.get ();
    }

    info::titolo_type& info::
    titolo ()
    {
      return this->titolo_.get ();
    }

    void info::
    titolo (const titolo_type& x)
    {
      this->titolo_.set (x);
    }

    void info::
    titolo (::std::auto_ptr< titolo_type > x)
    {
      this->titolo_.set (x);
    }

    const info::proprietario_type& info::
    proprietario () const
    {
      return this->proprietario_.get ();
    }

    info::proprietario_type& info::
    proprietario ()
    {
      return this->proprietario_.get ();
    }

    void info::
    proprietario (const proprietario_type& x)
    {
      this->proprietario_.set (x);
    }

    void info::
    proprietario (::std::auto_ptr< proprietario_type > x)
    {
      this->proprietario_.set (x);
    }

    const info::inizio_type& info::
    inizio () const
    {
      return this->inizio_.get ();
    }

    info::inizio_type& info::
    inizio ()
    {
      return this->inizio_.get ();
    }

    void info::
    inizio (const inizio_type& x)
    {
      this->inizio_.set (x);
    }

    void info::
    inizio (::std::auto_ptr< inizio_type > x)
    {
      this->inizio_.set (x);
    }

    const info::ambiti_type& info::
    ambiti () const
    {
      return this->ambiti_.get ();
    }

    info::ambiti_type& info::
    ambiti ()
    {
      return this->ambiti_.get ();
    }

    void info::
    ambiti (const ambiti_type& x)
    {
      this->ambiti_.set (x);
    }

    void info::
    ambiti (::std::auto_ptr< ambiti_type > x)
    {
      this->ambiti_.set (x);
    }


    // ambiti
    // 

    const ambiti::ambito_sequence& ambiti::
    ambito () const
    {
      return this->ambito_;
    }

    ambiti::ambito_sequence& ambiti::
    ambito ()
    {
      return this->ambito_;
    }

    void ambiti::
    ambito (const ambito_sequence& s)
    {
      this->ambito_ = s;
    }


    // ambito
    // 

    const ambito::titolo_type& ambito::
    titolo () const
    {
      return this->titolo_.get ();
    }

    ambito::titolo_type& ambito::
    titolo ()
    {
      return this->titolo_.get ();
    }

    void ambito::
    titolo (const titolo_type& x)
    {
      this->titolo_.set (x);
    }

    void ambito::
    titolo (::std::auto_ptr< titolo_type > x)
    {
      this->titolo_.set (x);
    }

    const ambito::icon_optional& ambito::
    icon () const
    {
      return this->icon_;
    }

    ambito::icon_optional& ambito::
    icon ()
    {
      return this->icon_;
    }

    void ambito::
    icon (const icon_type& x)
    {
      this->icon_.set (x);
    }

    void ambito::
    icon (const icon_optional& x)
    {
      this->icon_ = x;
    }

    void ambito::
    icon (::std::auto_ptr< icon_type > x)
    {
      this->icon_.set (x);
    }


    // autorita
    // 

    const autorita::nome_sequence& autorita::
    nome () const
    {
      return this->nome_;
    }

    autorita::nome_sequence& autorita::
    nome ()
    {
      return this->nome_;
    }

    void autorita::
    nome (const nome_sequence& s)
    {
      this->nome_ = s;
    }


    // zecca
    // 

    const zecca::nome_optional& zecca::
    nome () const
    {
      return this->nome_;
    }

    zecca::nome_optional& zecca::
    nome ()
    {
      return this->nome_;
    }

    void zecca::
    nome (const nome_type& x)
    {
      this->nome_.set (x);
    }

    void zecca::
    nome (const nome_optional& x)
    {
      this->nome_ = x;
    }

    void zecca::
    nome (::std::auto_ptr< nome_type > x)
    {
      this->nome_.set (x);
    }

    const zecca::segno_optional& zecca::
    segno () const
    {
      return this->segno_;
    }

    zecca::segno_optional& zecca::
    segno ()
    {
      return this->segno_;
    }

    void zecca::
    segno (const segno_type& x)
    {
      this->segno_.set (x);
    }

    void zecca::
    segno (const segno_optional& x)
    {
      this->segno_ = x;
    }

    void zecca::
    segno (::std::auto_ptr< segno_type > x)
    {
      this->segno_.set (x);
    }


    // zecchiere
    // 

    const zecchiere::nome_optional& zecchiere::
    nome () const
    {
      return this->nome_;
    }

    zecchiere::nome_optional& zecchiere::
    nome ()
    {
      return this->nome_;
    }

    void zecchiere::
    nome (const nome_type& x)
    {
      this->nome_.set (x);
    }

    void zecchiere::
    nome (const nome_optional& x)
    {
      this->nome_ = x;
    }

    void zecchiere::
    nome (::std::auto_ptr< nome_type > x)
    {
      this->nome_.set (x);
    }

    const zecchiere::segno_optional& zecchiere::
    segno () const
    {
      return this->segno_;
    }

    zecchiere::segno_optional& zecchiere::
    segno ()
    {
      return this->segno_;
    }

    void zecchiere::
    segno (const segno_type& x)
    {
      this->segno_.set (x);
    }

    void zecchiere::
    segno (const segno_optional& x)
    {
      this->segno_ = x;
    }

    void zecchiere::
    segno (::std::auto_ptr< segno_type > x)
    {
      this->segno_.set (x);
    }

    const zecchiere::ruolo_optional& zecchiere::
    ruolo () const
    {
      return this->ruolo_;
    }

    zecchiere::ruolo_optional& zecchiere::
    ruolo ()
    {
      return this->ruolo_;
    }

    void zecchiere::
    ruolo (const ruolo_type& x)
    {
      this->ruolo_.set (x);
    }

    void zecchiere::
    ruolo (const ruolo_optional& x)
    {
      this->ruolo_ = x;
    }

    void zecchiere::
    ruolo (::std::auto_ptr< ruolo_type > x)
    {
      this->ruolo_.set (x);
    }


    // legenda
    // 

    const legenda::testo_type& legenda::
    testo () const
    {
      return this->testo_.get ();
    }

    legenda::testo_type& legenda::
    testo ()
    {
      return this->testo_.get ();
    }

    void legenda::
    testo (const testo_type& x)
    {
      this->testo_.set (x);
    }

    void legenda::
    testo (::std::auto_ptr< testo_type > x)
    {
      this->testo_.set (x);
    }

    const legenda::scioglimento_optional& legenda::
    scioglimento () const
    {
      return this->scioglimento_;
    }

    legenda::scioglimento_optional& legenda::
    scioglimento ()
    {
      return this->scioglimento_;
    }

    void legenda::
    scioglimento (const scioglimento_type& x)
    {
      this->scioglimento_.set (x);
    }

    void legenda::
    scioglimento (const scioglimento_optional& x)
    {
      this->scioglimento_ = x;
    }

    void legenda::
    scioglimento (::std::auto_ptr< scioglimento_type > x)
    {
      this->scioglimento_.set (x);
    }


    // descrizioni
    // 

    const descrizioni::descrizione_type& descrizioni::
    descrizione () const
    {
      return this->descrizione_.get ();
    }

    descrizioni::descrizione_type& descrizioni::
    descrizione ()
    {
      return this->descrizione_.get ();
    }

    void descrizioni::
    descrizione (const descrizione_type& x)
    {
      this->descrizione_.set (x);
    }

    void descrizioni::
    descrizione (::std::auto_ptr< descrizione_type > x)
    {
      this->descrizione_.set (x);
    }

    const descrizioni::legenda_sequence& descrizioni::
    legenda () const
    {
      return this->legenda_;
    }

    descrizioni::legenda_sequence& descrizioni::
    legenda ()
    {
      return this->legenda_;
    }

    void descrizioni::
    legenda (const legenda_sequence& s)
    {
      this->legenda_ = s;
    }

    const descrizioni::fileImmagine_optional& descrizioni::
    fileImmagine () const
    {
      return this->fileImmagine_;
    }

    descrizioni::fileImmagine_optional& descrizioni::
    fileImmagine ()
    {
      return this->fileImmagine_;
    }

    void descrizioni::
    fileImmagine (const fileImmagine_type& x)
    {
      this->fileImmagine_.set (x);
    }

    void descrizioni::
    fileImmagine (const fileImmagine_optional& x)
    {
      this->fileImmagine_ = x;
    }

    void descrizioni::
    fileImmagine (::std::auto_ptr< fileImmagine_type > x)
    {
      this->fileImmagine_.set (x);
    }


    // misura
    // 

    const misura::unita_type& misura::
    unita () const
    {
      return this->unita_.get ();
    }

    misura::unita_type& misura::
    unita ()
    {
      return this->unita_.get ();
    }

    void misura::
    unita (const unita_type& x)
    {
      this->unita_.set (x);
    }

    void misura::
    unita (::std::auto_ptr< unita_type > x)
    {
      this->unita_.set (x);
    }

    const misura::valore_type& misura::
    valore () const
    {
      return this->valore_.get ();
    }

    misura::valore_type& misura::
    valore ()
    {
      return this->valore_.get ();
    }

    void misura::
    valore (const valore_type& x)
    {
      this->valore_.set (x);
    }


    // nominale
    // 

    const nominale::valuta_type& nominale::
    valuta () const
    {
      return this->valuta_.get ();
    }

    nominale::valuta_type& nominale::
    valuta ()
    {
      return this->valuta_.get ();
    }

    void nominale::
    valuta (const valuta_type& x)
    {
      this->valuta_.set (x);
    }

    void nominale::
    valuta (::std::auto_ptr< valuta_type > x)
    {
      this->valuta_.set (x);
    }

    const nominale::valore_type& nominale::
    valore () const
    {
      return this->valore_.get ();
    }

    nominale::valore_type& nominale::
    valore ()
    {
      return this->valore_.get ();
    }

    void nominale::
    valore (const valore_type& x)
    {
      this->valore_.set (x);
    }

    void nominale::
    valore (::std::auto_ptr< valore_type > x)
    {
      this->valore_.set (x);
    }


    // libro
    // 

    const libro::sigla_type& libro::
    sigla () const
    {
      return this->sigla_.get ();
    }

    libro::sigla_type& libro::
    sigla ()
    {
      return this->sigla_.get ();
    }

    void libro::
    sigla (const sigla_type& x)
    {
      this->sigla_.set (x);
    }

    void libro::
    sigla (::std::auto_ptr< sigla_type > x)
    {
      this->sigla_.set (x);
    }

    const libro::numero_type& libro::
    numero () const
    {
      return this->numero_.get ();
    }

    libro::numero_type& libro::
    numero ()
    {
      return this->numero_.get ();
    }

    void libro::
    numero (const numero_type& x)
    {
      this->numero_.set (x);
    }

    void libro::
    numero (::std::auto_ptr< numero_type > x)
    {
      this->numero_.set (x);
    }


    // asta
    // 

    const asta::casa_type& asta::
    casa () const
    {
      return this->casa_.get ();
    }

    asta::casa_type& asta::
    casa ()
    {
      return this->casa_.get ();
    }

    void asta::
    casa (const casa_type& x)
    {
      this->casa_.set (x);
    }

    void asta::
    casa (::std::auto_ptr< casa_type > x)
    {
      this->casa_.set (x);
    }

    const asta::idAsta_type& asta::
    idAsta () const
    {
      return this->idAsta_.get ();
    }

    asta::idAsta_type& asta::
    idAsta ()
    {
      return this->idAsta_.get ();
    }

    void asta::
    idAsta (const idAsta_type& x)
    {
      this->idAsta_.set (x);
    }

    void asta::
    idAsta (::std::auto_ptr< idAsta_type > x)
    {
      this->idAsta_.set (x);
    }

    const asta::data_type& asta::
    data () const
    {
      return this->data_.get ();
    }

    asta::data_type& asta::
    data ()
    {
      return this->data_.get ();
    }

    void asta::
    data (const data_type& x)
    {
      this->data_.set (x);
    }

    void asta::
    data (::std::auto_ptr< data_type > x)
    {
      this->data_.set (x);
    }

    const asta::lotto_type& asta::
    lotto () const
    {
      return this->lotto_.get ();
    }

    asta::lotto_type& asta::
    lotto ()
    {
      return this->lotto_.get ();
    }

    void asta::
    lotto (const lotto_type& x)
    {
      this->lotto_.set (x);
    }

    void asta::
    lotto (::std::auto_ptr< lotto_type > x)
    {
      this->lotto_.set (x);
    }

    const asta::stima_type& asta::
    stima () const
    {
      return this->stima_.get ();
    }

    asta::stima_type& asta::
    stima ()
    {
      return this->stima_.get ();
    }

    void asta::
    stima (const stima_type& x)
    {
      this->stima_.set (x);
    }

    void asta::
    stima (::std::auto_ptr< stima_type > x)
    {
      this->stima_.set (x);
    }

    const asta::aggiudicazione_type& asta::
    aggiudicazione () const
    {
      return this->aggiudicazione_.get ();
    }

    asta::aggiudicazione_type& asta::
    aggiudicazione ()
    {
      return this->aggiudicazione_.get ();
    }

    void asta::
    aggiudicazione (const aggiudicazione_type& x)
    {
      this->aggiudicazione_.set (x);
    }

    void asta::
    aggiudicazione (::std::auto_ptr< aggiudicazione_type > x)
    {
      this->aggiudicazione_.set (x);
    }


    // documentoAddizionale
    // 

    const documentoAddizionale::filename_type& documentoAddizionale::
    filename () const
    {
      return this->filename_.get ();
    }

    documentoAddizionale::filename_type& documentoAddizionale::
    filename ()
    {
      return this->filename_.get ();
    }

    void documentoAddizionale::
    filename (const filename_type& x)
    {
      this->filename_.set (x);
    }

    void documentoAddizionale::
    filename (::std::auto_ptr< filename_type > x)
    {
      this->filename_.set (x);
    }

    const documentoAddizionale::descrizione_type& documentoAddizionale::
    descrizione () const
    {
      return this->descrizione_.get ();
    }

    documentoAddizionale::descrizione_type& documentoAddizionale::
    descrizione ()
    {
      return this->descrizione_.get ();
    }

    void documentoAddizionale::
    descrizione (const descrizione_type& x)
    {
      this->descrizione_.set (x);
    }

    void documentoAddizionale::
    descrizione (::std::auto_ptr< descrizione_type > x)
    {
      this->descrizione_.set (x);
    }


    // documentiAggiuntivi
    // 

    const documentiAggiuntivi::documento_sequence& documentiAggiuntivi::
    documento () const
    {
      return this->documento_;
    }

    documentiAggiuntivi::documento_sequence& documentiAggiuntivi::
    documento ()
    {
      return this->documento_;
    }

    void documentiAggiuntivi::
    documento (const documento_sequence& s)
    {
      this->documento_ = s;
    }


    // letteratura
    // 

    const letteratura::libro_sequence& letteratura::
    libro () const
    {
      return this->libro_;
    }

    letteratura::libro_sequence& letteratura::
    libro ()
    {
      return this->libro_;
    }

    void letteratura::
    libro (const libro_sequence& s)
    {
      this->libro_ = s;
    }

    const letteratura::asta_sequence& letteratura::
    asta () const
    {
      return this->asta_;
    }

    letteratura::asta_sequence& letteratura::
    asta ()
    {
      return this->asta_;
    }

    void letteratura::
    asta (const asta_sequence& s)
    {
      this->asta_ = s;
    }


    // note
    // 

    const note::nota_sequence& note::
    nota () const
    {
      return this->nota_;
    }

    note::nota_sequence& note::
    nota ()
    {
      return this->nota_;
    }

    void note::
    nota (const nota_sequence& s)
    {
      this->nota_ = s;
    }


    // posizione
    // 

    const posizione::contenitore_type& posizione::
    contenitore () const
    {
      return this->contenitore_.get ();
    }

    posizione::contenitore_type& posizione::
    contenitore ()
    {
      return this->contenitore_.get ();
    }

    void posizione::
    contenitore (const contenitore_type& x)
    {
      this->contenitore_.set (x);
    }

    const posizione::vassoio_type& posizione::
    vassoio () const
    {
      return this->vassoio_.get ();
    }

    posizione::vassoio_type& posizione::
    vassoio ()
    {
      return this->vassoio_.get ();
    }

    void posizione::
    vassoio (const vassoio_type& x)
    {
      this->vassoio_.set (x);
    }

    const posizione::riga_type& posizione::
    riga () const
    {
      return this->riga_.get ();
    }

    posizione::riga_type& posizione::
    riga ()
    {
      return this->riga_.get ();
    }

    void posizione::
    riga (const riga_type& x)
    {
      this->riga_.set (x);
    }

    const posizione::colonna_type& posizione::
    colonna () const
    {
      return this->colonna_.get ();
    }

    posizione::colonna_type& posizione::
    colonna ()
    {
      return this->colonna_.get ();
    }

    void posizione::
    colonna (const colonna_type& x)
    {
      this->colonna_.set (x);
    }


    // datiAcquisto
    // 

    const datiAcquisto::luogo_type& datiAcquisto::
    luogo () const
    {
      return this->luogo_.get ();
    }

    datiAcquisto::luogo_type& datiAcquisto::
    luogo ()
    {
      return this->luogo_.get ();
    }

    void datiAcquisto::
    luogo (const luogo_type& x)
    {
      this->luogo_.set (x);
    }

    void datiAcquisto::
    luogo (::std::auto_ptr< luogo_type > x)
    {
      this->luogo_.set (x);
    }

    const datiAcquisto::data_type& datiAcquisto::
    data () const
    {
      return this->data_.get ();
    }

    datiAcquisto::data_type& datiAcquisto::
    data ()
    {
      return this->data_.get ();
    }

    void datiAcquisto::
    data (const data_type& x)
    {
      this->data_.set (x);
    }

    void datiAcquisto::
    data (::std::auto_ptr< data_type > x)
    {
      this->data_.set (x);
    }

    const datiAcquisto::prezzo_type& datiAcquisto::
    prezzo () const
    {
      return this->prezzo_.get ();
    }

    datiAcquisto::prezzo_type& datiAcquisto::
    prezzo ()
    {
      return this->prezzo_.get ();
    }

    void datiAcquisto::
    prezzo (const prezzo_type& x)
    {
      this->prezzo_.set (x);
    }

    void datiAcquisto::
    prezzo (::std::auto_ptr< prezzo_type > x)
    {
      this->prezzo_.set (x);
    }


    // datiFisici
    // 

    const datiFisici::peso_type& datiFisici::
    peso () const
    {
      return this->peso_.get ();
    }

    datiFisici::peso_type& datiFisici::
    peso ()
    {
      return this->peso_.get ();
    }

    void datiFisici::
    peso (const peso_type& x)
    {
      this->peso_.set (x);
    }

    void datiFisici::
    peso (::std::auto_ptr< peso_type > x)
    {
      this->peso_.set (x);
    }

    const datiFisici::diametro_type& datiFisici::
    diametro () const
    {
      return this->diametro_.get ();
    }

    datiFisici::diametro_type& datiFisici::
    diametro ()
    {
      return this->diametro_.get ();
    }

    void datiFisici::
    diametro (const diametro_type& x)
    {
      this->diametro_.set (x);
    }

    void datiFisici::
    diametro (::std::auto_ptr< diametro_type > x)
    {
      this->diametro_.set (x);
    }

    const datiFisici::forma_type& datiFisici::
    forma () const
    {
      return this->forma_.get ();
    }

    datiFisici::forma_type& datiFisici::
    forma ()
    {
      return this->forma_.get ();
    }

    void datiFisici::
    forma (const forma_type& x)
    {
      this->forma_.set (x);
    }

    void datiFisici::
    forma (::std::auto_ptr< forma_type > x)
    {
      this->forma_.set (x);
    }

    const datiFisici::metallo_type& datiFisici::
    metallo () const
    {
      return this->metallo_.get ();
    }

    datiFisici::metallo_type& datiFisici::
    metallo ()
    {
      return this->metallo_.get ();
    }

    void datiFisici::
    metallo (const metallo_type& x)
    {
      this->metallo_.set (x);
    }

    void datiFisici::
    metallo (::std::auto_ptr< metallo_type > x)
    {
      this->metallo_.set (x);
    }


    // datiArtistici
    // 

    const datiArtistici::dritto_type& datiArtistici::
    dritto () const
    {
      return this->dritto_.get ();
    }

    datiArtistici::dritto_type& datiArtistici::
    dritto ()
    {
      return this->dritto_.get ();
    }

    void datiArtistici::
    dritto (const dritto_type& x)
    {
      this->dritto_.set (x);
    }

    void datiArtistici::
    dritto (::std::auto_ptr< dritto_type > x)
    {
      this->dritto_.set (x);
    }

    const datiArtistici::rovescio_type& datiArtistici::
    rovescio () const
    {
      return this->rovescio_.get ();
    }

    datiArtistici::rovescio_type& datiArtistici::
    rovescio ()
    {
      return this->rovescio_.get ();
    }

    void datiArtistici::
    rovescio (const rovescio_type& x)
    {
      this->rovescio_.set (x);
    }

    void datiArtistici::
    rovescio (::std::auto_ptr< rovescio_type > x)
    {
      this->rovescio_.set (x);
    }

    const datiArtistici::taglio_type& datiArtistici::
    taglio () const
    {
      return this->taglio_.get ();
    }

    datiArtistici::taglio_type& datiArtistici::
    taglio ()
    {
      return this->taglio_.get ();
    }

    void datiArtistici::
    taglio (const taglio_type& x)
    {
      this->taglio_.set (x);
    }

    void datiArtistici::
    taglio (::std::auto_ptr< taglio_type > x)
    {
      this->taglio_.set (x);
    }


    // zecchieri
    // 

    const zecchieri::zecchiere_sequence& zecchieri::
    zecchiere () const
    {
      return this->zecchiere_;
    }

    zecchieri::zecchiere_sequence& zecchieri::
    zecchiere ()
    {
      return this->zecchiere_;
    }

    void zecchieri::
    zecchiere (const zecchiere_sequence& s)
    {
      this->zecchiere_ = s;
    }


    // stato
    // 

    const stato::colore_type& stato::
    colore () const
    {
      return this->colore_.get ();
    }

    stato::colore_type& stato::
    colore ()
    {
      return this->colore_.get ();
    }

    void stato::
    colore (const colore_type& x)
    {
      this->colore_.set (x);
    }

    void stato::
    colore (::std::auto_ptr< colore_type > x)
    {
      this->colore_.set (x);
    }

    const stato::motivo_type& stato::
    motivo () const
    {
      return this->motivo_.get ();
    }

    stato::motivo_type& stato::
    motivo ()
    {
      return this->motivo_.get ();
    }

    void stato::
    motivo (const motivo_type& x)
    {
      this->motivo_.set (x);
    }

    void stato::
    motivo (::std::auto_ptr< motivo_type > x)
    {
      this->motivo_.set (x);
    }


    // moneta
    // 

    const moneta::ambiti_optional& moneta::
    ambiti () const
    {
      return this->ambiti_;
    }

    moneta::ambiti_optional& moneta::
    ambiti ()
    {
      return this->ambiti_;
    }

    void moneta::
    ambiti (const ambiti_type& x)
    {
      this->ambiti_.set (x);
    }

    void moneta::
    ambiti (const ambiti_optional& x)
    {
      this->ambiti_ = x;
    }

    void moneta::
    ambiti (::std::auto_ptr< ambiti_type > x)
    {
      this->ambiti_.set (x);
    }

    const moneta::paese_type& moneta::
    paese () const
    {
      return this->paese_.get ();
    }

    moneta::paese_type& moneta::
    paese ()
    {
      return this->paese_.get ();
    }

    void moneta::
    paese (const paese_type& x)
    {
      this->paese_.set (x);
    }

    void moneta::
    paese (::std::auto_ptr< paese_type > x)
    {
      this->paese_.set (x);
    }

    const moneta::autorita_optional& moneta::
    autorita () const
    {
      return this->autorita_;
    }

    moneta::autorita_optional& moneta::
    autorita ()
    {
      return this->autorita_;
    }

    void moneta::
    autorita (const autorita_type& x)
    {
      this->autorita_.set (x);
    }

    void moneta::
    autorita (const autorita_optional& x)
    {
      this->autorita_ = x;
    }

    void moneta::
    autorita (::std::auto_ptr< autorita_type > x)
    {
      this->autorita_.set (x);
    }

    const moneta::anno_optional& moneta::
    anno () const
    {
      return this->anno_;
    }

    moneta::anno_optional& moneta::
    anno ()
    {
      return this->anno_;
    }

    void moneta::
    anno (const anno_type& x)
    {
      this->anno_.set (x);
    }

    void moneta::
    anno (const anno_optional& x)
    {
      this->anno_ = x;
    }

    void moneta::
    anno (::std::auto_ptr< anno_type > x)
    {
      this->anno_.set (x);
    }

    const moneta::nominale_type& moneta::
    nominale () const
    {
      return this->nominale_.get ();
    }

    moneta::nominale_type& moneta::
    nominale ()
    {
      return this->nominale_.get ();
    }

    void moneta::
    nominale (const nominale_type& x)
    {
      this->nominale_.set (x);
    }

    void moneta::
    nominale (::std::auto_ptr< nominale_type > x)
    {
      this->nominale_.set (x);
    }

    const moneta::zecca_optional& moneta::
    zecca () const
    {
      return this->zecca_;
    }

    moneta::zecca_optional& moneta::
    zecca ()
    {
      return this->zecca_;
    }

    void moneta::
    zecca (const zecca_type& x)
    {
      this->zecca_.set (x);
    }

    void moneta::
    zecca (const zecca_optional& x)
    {
      this->zecca_ = x;
    }

    void moneta::
    zecca (::std::auto_ptr< zecca_type > x)
    {
      this->zecca_.set (x);
    }

    const moneta::zecchieri_optional& moneta::
    zecchieri () const
    {
      return this->zecchieri_;
    }

    moneta::zecchieri_optional& moneta::
    zecchieri ()
    {
      return this->zecchieri_;
    }

    void moneta::
    zecchieri (const zecchieri_type& x)
    {
      this->zecchieri_.set (x);
    }

    void moneta::
    zecchieri (const zecchieri_optional& x)
    {
      this->zecchieri_ = x;
    }

    void moneta::
    zecchieri (::std::auto_ptr< zecchieri_type > x)
    {
      this->zecchieri_.set (x);
    }

    const moneta::datiArtistici_type& moneta::
    datiArtistici () const
    {
      return this->datiArtistici_.get ();
    }

    moneta::datiArtistici_type& moneta::
    datiArtistici ()
    {
      return this->datiArtistici_.get ();
    }

    void moneta::
    datiArtistici (const datiArtistici_type& x)
    {
      this->datiArtistici_.set (x);
    }

    void moneta::
    datiArtistici (::std::auto_ptr< datiArtistici_type > x)
    {
      this->datiArtistici_.set (x);
    }

    const moneta::datiFisici_type& moneta::
    datiFisici () const
    {
      return this->datiFisici_.get ();
    }

    moneta::datiFisici_type& moneta::
    datiFisici ()
    {
      return this->datiFisici_.get ();
    }

    void moneta::
    datiFisici (const datiFisici_type& x)
    {
      this->datiFisici_.set (x);
    }

    void moneta::
    datiFisici (::std::auto_ptr< datiFisici_type > x)
    {
      this->datiFisici_.set (x);
    }

    const moneta::datiAcquisto_type& moneta::
    datiAcquisto () const
    {
      return this->datiAcquisto_.get ();
    }

    moneta::datiAcquisto_type& moneta::
    datiAcquisto ()
    {
      return this->datiAcquisto_.get ();
    }

    void moneta::
    datiAcquisto (const datiAcquisto_type& x)
    {
      this->datiAcquisto_.set (x);
    }

    void moneta::
    datiAcquisto (::std::auto_ptr< datiAcquisto_type > x)
    {
      this->datiAcquisto_.set (x);
    }

    const moneta::posizione_optional& moneta::
    posizione () const
    {
      return this->posizione_;
    }

    moneta::posizione_optional& moneta::
    posizione ()
    {
      return this->posizione_;
    }

    void moneta::
    posizione (const posizione_type& x)
    {
      this->posizione_.set (x);
    }

    void moneta::
    posizione (const posizione_optional& x)
    {
      this->posizione_ = x;
    }

    void moneta::
    posizione (::std::auto_ptr< posizione_type > x)
    {
      this->posizione_.set (x);
    }

    const moneta::grado_optional& moneta::
    grado () const
    {
      return this->grado_;
    }

    moneta::grado_optional& moneta::
    grado ()
    {
      return this->grado_;
    }

    void moneta::
    grado (const grado_type& x)
    {
      this->grado_.set (x);
    }

    void moneta::
    grado (const grado_optional& x)
    {
      this->grado_ = x;
    }

    void moneta::
    grado (::std::auto_ptr< grado_type > x)
    {
      this->grado_.set (x);
    }

    const moneta::note_optional& moneta::
    note () const
    {
      return this->note_;
    }

    moneta::note_optional& moneta::
    note ()
    {
      return this->note_;
    }

    void moneta::
    note (const note_type& x)
    {
      this->note_.set (x);
    }

    void moneta::
    note (const note_optional& x)
    {
      this->note_ = x;
    }

    void moneta::
    note (::std::auto_ptr< note_type > x)
    {
      this->note_.set (x);
    }

    const moneta::letteratura_optional& moneta::
    letteratura () const
    {
      return this->letteratura_;
    }

    moneta::letteratura_optional& moneta::
    letteratura ()
    {
      return this->letteratura_;
    }

    void moneta::
    letteratura (const letteratura_type& x)
    {
      this->letteratura_.set (x);
    }

    void moneta::
    letteratura (const letteratura_optional& x)
    {
      this->letteratura_ = x;
    }

    void moneta::
    letteratura (::std::auto_ptr< letteratura_type > x)
    {
      this->letteratura_.set (x);
    }

    const moneta::itemAddizionali_optional& moneta::
    itemAddizionali () const
    {
      return this->itemAddizionali_;
    }

    moneta::itemAddizionali_optional& moneta::
    itemAddizionali ()
    {
      return this->itemAddizionali_;
    }

    void moneta::
    itemAddizionali (const itemAddizionali_type& x)
    {
      this->itemAddizionali_.set (x);
    }

    void moneta::
    itemAddizionali (const itemAddizionali_optional& x)
    {
      this->itemAddizionali_ = x;
    }

    void moneta::
    itemAddizionali (::std::auto_ptr< itemAddizionali_type > x)
    {
      this->itemAddizionali_.set (x);
    }

    const moneta::stato_type& moneta::
    stato () const
    {
      return this->stato_.get ();
    }

    moneta::stato_type& moneta::
    stato ()
    {
      return this->stato_.get ();
    }

    void moneta::
    stato (const stato_type& x)
    {
      this->stato_.set (x);
    }

    void moneta::
    stato (::std::auto_ptr< stato_type > x)
    {
      this->stato_.set (x);
    }

    const moneta::revisione_type& moneta::
    revisione () const
    {
      return this->revisione_.get ();
    }

    moneta::revisione_type& moneta::
    revisione ()
    {
      return this->revisione_.get ();
    }

    void moneta::
    revisione (const revisione_type& x)
    {
      this->revisione_.set (x);
    }

    void moneta::
    revisione (::std::auto_ptr< revisione_type > x)
    {
      this->revisione_.set (x);
    }

    const moneta::id_type& moneta::
    id () const
    {
      return this->id_.get ();
    }

    moneta::id_type& moneta::
    id ()
    {
      return this->id_.get ();
    }

    void moneta::
    id (const id_type& x)
    {
      this->id_.set (x);
    }

    void moneta::
    id (::std::auto_ptr< id_type > x)
    {
      this->id_.set (x);
    }


    // monete
    // 

    const monete::info_type& monete::
    info () const
    {
      return this->info_.get ();
    }

    monete::info_type& monete::
    info ()
    {
      return this->info_.get ();
    }

    void monete::
    info (const info_type& x)
    {
      this->info_.set (x);
    }

    void monete::
    info (::std::auto_ptr< info_type > x)
    {
      this->info_.set (x);
    }

    const monete::moneta_sequence& monete::
    moneta () const
    {
      return this->moneta_;
    }

    monete::moneta_sequence& monete::
    moneta ()
    {
      return this->moneta_;
    }

    void monete::
    moneta (const moneta_sequence& s)
    {
      this->moneta_ = s;
    }
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace gestColl
{
  namespace coins
  {
    // info
    //

    info::
    info (const titolo_type& titolo,
          const proprietario_type& proprietario,
          const inizio_type& inizio,
          const ambiti_type& ambiti)
    : ::xml_schema::type (),
      titolo_ (titolo, ::xml_schema::flags (), this),
      proprietario_ (proprietario, ::xml_schema::flags (), this),
      inizio_ (inizio, ::xml_schema::flags (), this),
      ambiti_ (ambiti, ::xml_schema::flags (), this)
    {
    }

    info::
    info (const titolo_type& titolo,
          const proprietario_type& proprietario,
          const inizio_type& inizio,
          ::std::auto_ptr< ambiti_type >& ambiti)
    : ::xml_schema::type (),
      titolo_ (titolo, ::xml_schema::flags (), this),
      proprietario_ (proprietario, ::xml_schema::flags (), this),
      inizio_ (inizio, ::xml_schema::flags (), this),
      ambiti_ (ambiti, ::xml_schema::flags (), this)
    {
    }

    info::
    info (const info& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      titolo_ (x.titolo_, f, this),
      proprietario_ (x.proprietario_, f, this),
      inizio_ (x.inizio_, f, this),
      ambiti_ (x.ambiti_, f, this)
    {
    }

    info::
    info (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      titolo_ (f, this),
      proprietario_ (f, this),
      inizio_ (f, this),
      ambiti_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void info::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // titolo
        //
        if (n.name () == L"titolo" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< titolo_type > r (
            titolo_traits::create (i, f, this));

          if (!titolo_.present ())
          {
            this->titolo_.set (r);
            continue;
          }
        }

        // proprietario
        //
        if (n.name () == L"proprietario" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< proprietario_type > r (
            proprietario_traits::create (i, f, this));

          if (!proprietario_.present ())
          {
            this->proprietario_.set (r);
            continue;
          }
        }

        // inizio
        //
        if (n.name () == L"inizio" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< inizio_type > r (
            inizio_traits::create (i, f, this));

          if (!inizio_.present ())
          {
            this->inizio_.set (r);
            continue;
          }
        }

        // ambiti
        //
        if (n.name () == L"ambiti" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< ambiti_type > r (
            ambiti_traits::create (i, f, this));

          if (!ambiti_.present ())
          {
            this->ambiti_.set (r);
            continue;
          }
        }

        break;
      }

      if (!titolo_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"titolo",
          L"http://gestColl/coins");
      }

      if (!proprietario_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"proprietario",
          L"http://gestColl/coins");
      }

      if (!inizio_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"inizio",
          L"http://gestColl/coins");
      }

      if (!ambiti_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"ambiti",
          L"http://gestColl/coins");
      }
    }

    info* info::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class info (*this, f, c);
    }

    info::
    ~info ()
    {
    }

    // ambiti
    //

    ambiti::
    ambiti ()
    : ::xml_schema::type (),
      ambito_ (::xml_schema::flags (), this)
    {
    }

    ambiti::
    ambiti (const ambiti& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ambito_ (x.ambito_, f, this)
    {
    }

    ambiti::
    ambiti (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ambito_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ambiti::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ambito
        //
        if (n.name () == L"ambito" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< ambito_type > r (
            ambito_traits::create (i, f, this));

          this->ambito_.push_back (r);
          continue;
        }

        break;
      }
    }

    ambiti* ambiti::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ambiti (*this, f, c);
    }

    ambiti::
    ~ambiti ()
    {
    }

    // ambito
    //

    ambito::
    ambito (const titolo_type& titolo)
    : ::xml_schema::type (),
      titolo_ (titolo, ::xml_schema::flags (), this),
      icon_ (::xml_schema::flags (), this)
    {
    }

    ambito::
    ambito (const ambito& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      titolo_ (x.titolo_, f, this),
      icon_ (x.icon_, f, this)
    {
    }

    ambito::
    ambito (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      titolo_ (f, this),
      icon_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void ambito::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // titolo
        //
        if (n.name () == L"titolo" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< titolo_type > r (
            titolo_traits::create (i, f, this));

          if (!titolo_.present ())
          {
            this->titolo_.set (r);
            continue;
          }
        }

        // icon
        //
        if (n.name () == L"icon" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< icon_type > r (
            icon_traits::create (i, f, this));

          if (!this->icon_)
          {
            this->icon_.set (r);
            continue;
          }
        }

        break;
      }

      if (!titolo_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"titolo",
          L"http://gestColl/coins");
      }
    }

    ambito* ambito::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class ambito (*this, f, c);
    }

    ambito::
    ~ambito ()
    {
    }

    // autorita
    //

    autorita::
    autorita ()
    : ::xml_schema::type (),
      nome_ (::xml_schema::flags (), this)
    {
    }

    autorita::
    autorita (const autorita& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      nome_ (x.nome_, f, this)
    {
    }

    autorita::
    autorita (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      nome_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void autorita::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // nome
        //
        if (n.name () == L"nome" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< nome_type > r (
            nome_traits::create (i, f, this));

          this->nome_.push_back (r);
          continue;
        }

        break;
      }
    }

    autorita* autorita::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class autorita (*this, f, c);
    }

    autorita::
    ~autorita ()
    {
    }

    // zecca
    //

    zecca::
    zecca ()
    : ::xml_schema::type (),
      nome_ (::xml_schema::flags (), this),
      segno_ (::xml_schema::flags (), this)
    {
    }

    zecca::
    zecca (const zecca& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      nome_ (x.nome_, f, this),
      segno_ (x.segno_, f, this)
    {
    }

    zecca::
    zecca (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      nome_ (f, this),
      segno_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void zecca::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // nome
        //
        if (n.name () == L"nome" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< nome_type > r (
            nome_traits::create (i, f, this));

          if (!this->nome_)
          {
            this->nome_.set (r);
            continue;
          }
        }

        // segno
        //
        if (n.name () == L"segno" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< segno_type > r (
            segno_traits::create (i, f, this));

          if (!this->segno_)
          {
            this->segno_.set (r);
            continue;
          }
        }

        break;
      }
    }

    zecca* zecca::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class zecca (*this, f, c);
    }

    zecca::
    ~zecca ()
    {
    }

    // zecchiere
    //

    zecchiere::
    zecchiere ()
    : ::xml_schema::type (),
      nome_ (::xml_schema::flags (), this),
      segno_ (::xml_schema::flags (), this),
      ruolo_ (::xml_schema::flags (), this)
    {
    }

    zecchiere::
    zecchiere (const zecchiere& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      nome_ (x.nome_, f, this),
      segno_ (x.segno_, f, this),
      ruolo_ (x.ruolo_, f, this)
    {
    }

    zecchiere::
    zecchiere (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      nome_ (f, this),
      segno_ (f, this),
      ruolo_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void zecchiere::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // nome
        //
        if (n.name () == L"nome" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< nome_type > r (
            nome_traits::create (i, f, this));

          if (!this->nome_)
          {
            this->nome_.set (r);
            continue;
          }
        }

        // segno
        //
        if (n.name () == L"segno" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< segno_type > r (
            segno_traits::create (i, f, this));

          if (!this->segno_)
          {
            this->segno_.set (r);
            continue;
          }
        }

        // ruolo
        //
        if (n.name () == L"ruolo" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< ruolo_type > r (
            ruolo_traits::create (i, f, this));

          if (!this->ruolo_)
          {
            this->ruolo_.set (r);
            continue;
          }
        }

        break;
      }
    }

    zecchiere* zecchiere::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class zecchiere (*this, f, c);
    }

    zecchiere::
    ~zecchiere ()
    {
    }

    // legenda
    //

    legenda::
    legenda (const testo_type& testo)
    : ::xml_schema::type (),
      testo_ (testo, ::xml_schema::flags (), this),
      scioglimento_ (::xml_schema::flags (), this)
    {
    }

    legenda::
    legenda (const legenda& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      testo_ (x.testo_, f, this),
      scioglimento_ (x.scioglimento_, f, this)
    {
    }

    legenda::
    legenda (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      testo_ (f, this),
      scioglimento_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void legenda::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // testo
        //
        if (n.name () == L"testo" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< testo_type > r (
            testo_traits::create (i, f, this));

          if (!testo_.present ())
          {
            this->testo_.set (r);
            continue;
          }
        }

        // scioglimento
        //
        if (n.name () == L"scioglimento" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< scioglimento_type > r (
            scioglimento_traits::create (i, f, this));

          if (!this->scioglimento_)
          {
            this->scioglimento_.set (r);
            continue;
          }
        }

        break;
      }

      if (!testo_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"testo",
          L"http://gestColl/coins");
      }
    }

    legenda* legenda::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class legenda (*this, f, c);
    }

    legenda::
    ~legenda ()
    {
    }

    // descrizioni
    //

    descrizioni::
    descrizioni (const descrizione_type& descrizione)
    : ::xml_schema::type (),
      descrizione_ (descrizione, ::xml_schema::flags (), this),
      legenda_ (::xml_schema::flags (), this),
      fileImmagine_ (::xml_schema::flags (), this)
    {
    }

    descrizioni::
    descrizioni (const descrizioni& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      descrizione_ (x.descrizione_, f, this),
      legenda_ (x.legenda_, f, this),
      fileImmagine_ (x.fileImmagine_, f, this)
    {
    }

    descrizioni::
    descrizioni (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      descrizione_ (f, this),
      legenda_ (f, this),
      fileImmagine_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void descrizioni::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // descrizione
        //
        if (n.name () == L"descrizione" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< descrizione_type > r (
            descrizione_traits::create (i, f, this));

          if (!descrizione_.present ())
          {
            this->descrizione_.set (r);
            continue;
          }
        }

        // legenda
        //
        if (n.name () == L"legenda" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< legenda_type > r (
            legenda_traits::create (i, f, this));

          this->legenda_.push_back (r);
          continue;
        }

        // fileImmagine
        //
        if (n.name () == L"fileImmagine" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< fileImmagine_type > r (
            fileImmagine_traits::create (i, f, this));

          if (!this->fileImmagine_)
          {
            this->fileImmagine_.set (r);
            continue;
          }
        }

        break;
      }

      if (!descrizione_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"descrizione",
          L"http://gestColl/coins");
      }
    }

    descrizioni* descrizioni::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class descrizioni (*this, f, c);
    }

    descrizioni::
    ~descrizioni ()
    {
    }

    // misura
    //

    misura::
    misura (const unita_type& unita,
            const valore_type& valore)
    : ::xml_schema::type (),
      unita_ (unita, ::xml_schema::flags (), this),
      valore_ (valore, ::xml_schema::flags (), this)
    {
    }

    misura::
    misura (const misura& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      unita_ (x.unita_, f, this),
      valore_ (x.valore_, f, this)
    {
    }

    misura::
    misura (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      unita_ (f, this),
      valore_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void misura::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // unita
        //
        if (n.name () == L"unita" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< unita_type > r (
            unita_traits::create (i, f, this));

          if (!unita_.present ())
          {
            this->unita_.set (r);
            continue;
          }
        }

        // valore
        //
        if (n.name () == L"valore" && n.namespace_ () == L"http://gestColl/coins")
        {
          if (!valore_.present ())
          {
            this->valore_.set (valore_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!unita_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"unita",
          L"http://gestColl/coins");
      }

      if (!valore_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"valore",
          L"http://gestColl/coins");
      }
    }

    misura* misura::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class misura (*this, f, c);
    }

    misura::
    ~misura ()
    {
    }

    // nominale
    //

    nominale::
    nominale (const valuta_type& valuta,
              const valore_type& valore)
    : ::xml_schema::type (),
      valuta_ (valuta, ::xml_schema::flags (), this),
      valore_ (valore, ::xml_schema::flags (), this)
    {
    }

    nominale::
    nominale (const nominale& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      valuta_ (x.valuta_, f, this),
      valore_ (x.valore_, f, this)
    {
    }

    nominale::
    nominale (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      valuta_ (f, this),
      valore_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void nominale::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // valuta
        //
        if (n.name () == L"valuta" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< valuta_type > r (
            valuta_traits::create (i, f, this));

          if (!valuta_.present ())
          {
            this->valuta_.set (r);
            continue;
          }
        }

        // valore
        //
        if (n.name () == L"valore" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< valore_type > r (
            valore_traits::create (i, f, this));

          if (!valore_.present ())
          {
            this->valore_.set (r);
            continue;
          }
        }

        break;
      }

      if (!valuta_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"valuta",
          L"http://gestColl/coins");
      }

      if (!valore_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"valore",
          L"http://gestColl/coins");
      }
    }

    nominale* nominale::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class nominale (*this, f, c);
    }

    nominale::
    ~nominale ()
    {
    }

    // libro
    //

    libro::
    libro (const sigla_type& sigla,
           const numero_type& numero)
    : ::xml_schema::type (),
      sigla_ (sigla, ::xml_schema::flags (), this),
      numero_ (numero, ::xml_schema::flags (), this)
    {
    }

    libro::
    libro (const libro& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      sigla_ (x.sigla_, f, this),
      numero_ (x.numero_, f, this)
    {
    }

    libro::
    libro (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      sigla_ (f, this),
      numero_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void libro::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // sigla
        //
        if (n.name () == L"sigla" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< sigla_type > r (
            sigla_traits::create (i, f, this));

          if (!sigla_.present ())
          {
            this->sigla_.set (r);
            continue;
          }
        }

        // numero
        //
        if (n.name () == L"numero" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< numero_type > r (
            numero_traits::create (i, f, this));

          if (!numero_.present ())
          {
            this->numero_.set (r);
            continue;
          }
        }

        break;
      }

      if (!sigla_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"sigla",
          L"http://gestColl/coins");
      }

      if (!numero_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"numero",
          L"http://gestColl/coins");
      }
    }

    libro* libro::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class libro (*this, f, c);
    }

    libro::
    ~libro ()
    {
    }

    // asta
    //

    asta::
    asta (const casa_type& casa,
          const idAsta_type& idAsta,
          const data_type& data,
          const lotto_type& lotto,
          const stima_type& stima,
          const aggiudicazione_type& aggiudicazione)
    : ::xml_schema::type (),
      casa_ (casa, ::xml_schema::flags (), this),
      idAsta_ (idAsta, ::xml_schema::flags (), this),
      data_ (data, ::xml_schema::flags (), this),
      lotto_ (lotto, ::xml_schema::flags (), this),
      stima_ (stima, ::xml_schema::flags (), this),
      aggiudicazione_ (aggiudicazione, ::xml_schema::flags (), this)
    {
    }

    asta::
    asta (const casa_type& casa,
          const idAsta_type& idAsta,
          const data_type& data,
          const lotto_type& lotto,
          ::std::auto_ptr< stima_type >& stima,
          ::std::auto_ptr< aggiudicazione_type >& aggiudicazione)
    : ::xml_schema::type (),
      casa_ (casa, ::xml_schema::flags (), this),
      idAsta_ (idAsta, ::xml_schema::flags (), this),
      data_ (data, ::xml_schema::flags (), this),
      lotto_ (lotto, ::xml_schema::flags (), this),
      stima_ (stima, ::xml_schema::flags (), this),
      aggiudicazione_ (aggiudicazione, ::xml_schema::flags (), this)
    {
    }

    asta::
    asta (const asta& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      casa_ (x.casa_, f, this),
      idAsta_ (x.idAsta_, f, this),
      data_ (x.data_, f, this),
      lotto_ (x.lotto_, f, this),
      stima_ (x.stima_, f, this),
      aggiudicazione_ (x.aggiudicazione_, f, this)
    {
    }

    asta::
    asta (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      casa_ (f, this),
      idAsta_ (f, this),
      data_ (f, this),
      lotto_ (f, this),
      stima_ (f, this),
      aggiudicazione_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void asta::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // casa
        //
        if (n.name () == L"casa" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< casa_type > r (
            casa_traits::create (i, f, this));

          if (!casa_.present ())
          {
            this->casa_.set (r);
            continue;
          }
        }

        // idAsta
        //
        if (n.name () == L"idAsta" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< idAsta_type > r (
            idAsta_traits::create (i, f, this));

          if (!idAsta_.present ())
          {
            this->idAsta_.set (r);
            continue;
          }
        }

        // data
        //
        if (n.name () == L"data" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< data_type > r (
            data_traits::create (i, f, this));

          if (!data_.present ())
          {
            this->data_.set (r);
            continue;
          }
        }

        // lotto
        //
        if (n.name () == L"lotto" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< lotto_type > r (
            lotto_traits::create (i, f, this));

          if (!lotto_.present ())
          {
            this->lotto_.set (r);
            continue;
          }
        }

        // stima
        //
        if (n.name () == L"stima" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< stima_type > r (
            stima_traits::create (i, f, this));

          if (!stima_.present ())
          {
            this->stima_.set (r);
            continue;
          }
        }

        // aggiudicazione
        //
        if (n.name () == L"aggiudicazione" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< aggiudicazione_type > r (
            aggiudicazione_traits::create (i, f, this));

          if (!aggiudicazione_.present ())
          {
            this->aggiudicazione_.set (r);
            continue;
          }
        }

        break;
      }

      if (!casa_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"casa",
          L"http://gestColl/coins");
      }

      if (!idAsta_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"idAsta",
          L"http://gestColl/coins");
      }

      if (!data_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"data",
          L"http://gestColl/coins");
      }

      if (!lotto_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"lotto",
          L"http://gestColl/coins");
      }

      if (!stima_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"stima",
          L"http://gestColl/coins");
      }

      if (!aggiudicazione_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"aggiudicazione",
          L"http://gestColl/coins");
      }
    }

    asta* asta::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class asta (*this, f, c);
    }

    asta::
    ~asta ()
    {
    }

    // documentoAddizionale
    //

    documentoAddizionale::
    documentoAddizionale (const filename_type& filename,
                          const descrizione_type& descrizione)
    : ::xml_schema::type (),
      filename_ (filename, ::xml_schema::flags (), this),
      descrizione_ (descrizione, ::xml_schema::flags (), this)
    {
    }

    documentoAddizionale::
    documentoAddizionale (const documentoAddizionale& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      filename_ (x.filename_, f, this),
      descrizione_ (x.descrizione_, f, this)
    {
    }

    documentoAddizionale::
    documentoAddizionale (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      filename_ (f, this),
      descrizione_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void documentoAddizionale::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // filename
        //
        if (n.name () == L"filename" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< filename_type > r (
            filename_traits::create (i, f, this));

          if (!filename_.present ())
          {
            this->filename_.set (r);
            continue;
          }
        }

        // descrizione
        //
        if (n.name () == L"descrizione" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< descrizione_type > r (
            descrizione_traits::create (i, f, this));

          if (!descrizione_.present ())
          {
            this->descrizione_.set (r);
            continue;
          }
        }

        break;
      }

      if (!filename_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"filename",
          L"http://gestColl/coins");
      }

      if (!descrizione_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"descrizione",
          L"http://gestColl/coins");
      }
    }

    documentoAddizionale* documentoAddizionale::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class documentoAddizionale (*this, f, c);
    }

    documentoAddizionale::
    ~documentoAddizionale ()
    {
    }

    // documentiAggiuntivi
    //

    documentiAggiuntivi::
    documentiAggiuntivi ()
    : ::xml_schema::type (),
      documento_ (::xml_schema::flags (), this)
    {
    }

    documentiAggiuntivi::
    documentiAggiuntivi (const documentiAggiuntivi& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      documento_ (x.documento_, f, this)
    {
    }

    documentiAggiuntivi::
    documentiAggiuntivi (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      documento_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void documentiAggiuntivi::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // documento
        //
        if (n.name () == L"documento" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< documento_type > r (
            documento_traits::create (i, f, this));

          this->documento_.push_back (r);
          continue;
        }

        break;
      }
    }

    documentiAggiuntivi* documentiAggiuntivi::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class documentiAggiuntivi (*this, f, c);
    }

    documentiAggiuntivi::
    ~documentiAggiuntivi ()
    {
    }

    // letteratura
    //

    letteratura::
    letteratura ()
    : ::xml_schema::type (),
      libro_ (::xml_schema::flags (), this),
      asta_ (::xml_schema::flags (), this)
    {
    }

    letteratura::
    letteratura (const letteratura& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      libro_ (x.libro_, f, this),
      asta_ (x.asta_, f, this)
    {
    }

    letteratura::
    letteratura (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      libro_ (f, this),
      asta_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void letteratura::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // libro
        //
        if (n.name () == L"libro" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< libro_type > r (
            libro_traits::create (i, f, this));

          this->libro_.push_back (r);
          continue;
        }

        // asta
        //
        if (n.name () == L"asta" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< asta_type > r (
            asta_traits::create (i, f, this));

          this->asta_.push_back (r);
          continue;
        }

        break;
      }
    }

    letteratura* letteratura::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class letteratura (*this, f, c);
    }

    letteratura::
    ~letteratura ()
    {
    }

    // note
    //

    note::
    note ()
    : ::xml_schema::type (),
      nota_ (::xml_schema::flags (), this)
    {
    }

    note::
    note (const note& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      nota_ (x.nota_, f, this)
    {
    }

    note::
    note (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      nota_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void note::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // nota
        //
        if (n.name () == L"nota" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< nota_type > r (
            nota_traits::create (i, f, this));

          this->nota_.push_back (r);
          continue;
        }

        break;
      }
    }

    note* note::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class note (*this, f, c);
    }

    note::
    ~note ()
    {
    }

    // posizione
    //

    posizione::
    posizione (const contenitore_type& contenitore,
               const vassoio_type& vassoio,
               const riga_type& riga,
               const colonna_type& colonna)
    : ::xml_schema::type (),
      contenitore_ (contenitore, ::xml_schema::flags (), this),
      vassoio_ (vassoio, ::xml_schema::flags (), this),
      riga_ (riga, ::xml_schema::flags (), this),
      colonna_ (colonna, ::xml_schema::flags (), this)
    {
    }

    posizione::
    posizione (const posizione& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      contenitore_ (x.contenitore_, f, this),
      vassoio_ (x.vassoio_, f, this),
      riga_ (x.riga_, f, this),
      colonna_ (x.colonna_, f, this)
    {
    }

    posizione::
    posizione (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      contenitore_ (f, this),
      vassoio_ (f, this),
      riga_ (f, this),
      colonna_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void posizione::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // contenitore
        //
        if (n.name () == L"contenitore" && n.namespace_ () == L"http://gestColl/coins")
        {
          if (!contenitore_.present ())
          {
            this->contenitore_.set (contenitore_traits::create (i, f, this));
            continue;
          }
        }

        // vassoio
        //
        if (n.name () == L"vassoio" && n.namespace_ () == L"http://gestColl/coins")
        {
          if (!vassoio_.present ())
          {
            this->vassoio_.set (vassoio_traits::create (i, f, this));
            continue;
          }
        }

        // riga
        //
        if (n.name () == L"riga" && n.namespace_ () == L"http://gestColl/coins")
        {
          if (!riga_.present ())
          {
            this->riga_.set (riga_traits::create (i, f, this));
            continue;
          }
        }

        // colonna
        //
        if (n.name () == L"colonna" && n.namespace_ () == L"http://gestColl/coins")
        {
          if (!colonna_.present ())
          {
            this->colonna_.set (colonna_traits::create (i, f, this));
            continue;
          }
        }

        break;
      }

      if (!contenitore_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"contenitore",
          L"http://gestColl/coins");
      }

      if (!vassoio_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"vassoio",
          L"http://gestColl/coins");
      }

      if (!riga_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"riga",
          L"http://gestColl/coins");
      }

      if (!colonna_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"colonna",
          L"http://gestColl/coins");
      }
    }

    posizione* posizione::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class posizione (*this, f, c);
    }

    posizione::
    ~posizione ()
    {
    }

    // datiAcquisto
    //

    datiAcquisto::
    datiAcquisto (const luogo_type& luogo,
                  const data_type& data,
                  const prezzo_type& prezzo)
    : ::xml_schema::type (),
      luogo_ (luogo, ::xml_schema::flags (), this),
      data_ (data, ::xml_schema::flags (), this),
      prezzo_ (prezzo, ::xml_schema::flags (), this)
    {
    }

    datiAcquisto::
    datiAcquisto (const luogo_type& luogo,
                  const data_type& data,
                  ::std::auto_ptr< prezzo_type >& prezzo)
    : ::xml_schema::type (),
      luogo_ (luogo, ::xml_schema::flags (), this),
      data_ (data, ::xml_schema::flags (), this),
      prezzo_ (prezzo, ::xml_schema::flags (), this)
    {
    }

    datiAcquisto::
    datiAcquisto (const datiAcquisto& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      luogo_ (x.luogo_, f, this),
      data_ (x.data_, f, this),
      prezzo_ (x.prezzo_, f, this)
    {
    }

    datiAcquisto::
    datiAcquisto (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      luogo_ (f, this),
      data_ (f, this),
      prezzo_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void datiAcquisto::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // luogo
        //
        if (n.name () == L"luogo" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< luogo_type > r (
            luogo_traits::create (i, f, this));

          if (!luogo_.present ())
          {
            this->luogo_.set (r);
            continue;
          }
        }

        // data
        //
        if (n.name () == L"data" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< data_type > r (
            data_traits::create (i, f, this));

          if (!data_.present ())
          {
            this->data_.set (r);
            continue;
          }
        }

        // prezzo
        //
        if (n.name () == L"prezzo" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< prezzo_type > r (
            prezzo_traits::create (i, f, this));

          if (!prezzo_.present ())
          {
            this->prezzo_.set (r);
            continue;
          }
        }

        break;
      }

      if (!luogo_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"luogo",
          L"http://gestColl/coins");
      }

      if (!data_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"data",
          L"http://gestColl/coins");
      }

      if (!prezzo_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"prezzo",
          L"http://gestColl/coins");
      }
    }

    datiAcquisto* datiAcquisto::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class datiAcquisto (*this, f, c);
    }

    datiAcquisto::
    ~datiAcquisto ()
    {
    }

    // datiFisici
    //

    datiFisici::
    datiFisici (const peso_type& peso,
                const diametro_type& diametro,
                const forma_type& forma,
                const metallo_type& metallo)
    : ::xml_schema::type (),
      peso_ (peso, ::xml_schema::flags (), this),
      diametro_ (diametro, ::xml_schema::flags (), this),
      forma_ (forma, ::xml_schema::flags (), this),
      metallo_ (metallo, ::xml_schema::flags (), this)
    {
    }

    datiFisici::
    datiFisici (::std::auto_ptr< peso_type >& peso,
                ::std::auto_ptr< diametro_type >& diametro,
                const forma_type& forma,
                const metallo_type& metallo)
    : ::xml_schema::type (),
      peso_ (peso, ::xml_schema::flags (), this),
      diametro_ (diametro, ::xml_schema::flags (), this),
      forma_ (forma, ::xml_schema::flags (), this),
      metallo_ (metallo, ::xml_schema::flags (), this)
    {
    }

    datiFisici::
    datiFisici (const datiFisici& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      peso_ (x.peso_, f, this),
      diametro_ (x.diametro_, f, this),
      forma_ (x.forma_, f, this),
      metallo_ (x.metallo_, f, this)
    {
    }

    datiFisici::
    datiFisici (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      peso_ (f, this),
      diametro_ (f, this),
      forma_ (f, this),
      metallo_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void datiFisici::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // peso
        //
        if (n.name () == L"peso" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< peso_type > r (
            peso_traits::create (i, f, this));

          if (!peso_.present ())
          {
            this->peso_.set (r);
            continue;
          }
        }

        // diametro
        //
        if (n.name () == L"diametro" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< diametro_type > r (
            diametro_traits::create (i, f, this));

          if (!diametro_.present ())
          {
            this->diametro_.set (r);
            continue;
          }
        }

        // forma
        //
        if (n.name () == L"forma" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< forma_type > r (
            forma_traits::create (i, f, this));

          if (!forma_.present ())
          {
            this->forma_.set (r);
            continue;
          }
        }

        // metallo
        //
        if (n.name () == L"metallo" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< metallo_type > r (
            metallo_traits::create (i, f, this));

          if (!metallo_.present ())
          {
            this->metallo_.set (r);
            continue;
          }
        }

        break;
      }

      if (!peso_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"peso",
          L"http://gestColl/coins");
      }

      if (!diametro_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"diametro",
          L"http://gestColl/coins");
      }

      if (!forma_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"forma",
          L"http://gestColl/coins");
      }

      if (!metallo_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"metallo",
          L"http://gestColl/coins");
      }
    }

    datiFisici* datiFisici::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class datiFisici (*this, f, c);
    }

    datiFisici::
    ~datiFisici ()
    {
    }

    // datiArtistici
    //

    datiArtistici::
    datiArtistici (const dritto_type& dritto,
                   const rovescio_type& rovescio,
                   const taglio_type& taglio)
    : ::xml_schema::type (),
      dritto_ (dritto, ::xml_schema::flags (), this),
      rovescio_ (rovescio, ::xml_schema::flags (), this),
      taglio_ (taglio, ::xml_schema::flags (), this)
    {
    }

    datiArtistici::
    datiArtistici (::std::auto_ptr< dritto_type >& dritto,
                   ::std::auto_ptr< rovescio_type >& rovescio,
                   ::std::auto_ptr< taglio_type >& taglio)
    : ::xml_schema::type (),
      dritto_ (dritto, ::xml_schema::flags (), this),
      rovescio_ (rovescio, ::xml_schema::flags (), this),
      taglio_ (taglio, ::xml_schema::flags (), this)
    {
    }

    datiArtistici::
    datiArtistici (const datiArtistici& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      dritto_ (x.dritto_, f, this),
      rovescio_ (x.rovescio_, f, this),
      taglio_ (x.taglio_, f, this)
    {
    }

    datiArtistici::
    datiArtistici (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      dritto_ (f, this),
      rovescio_ (f, this),
      taglio_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void datiArtistici::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // dritto
        //
        if (n.name () == L"dritto" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< dritto_type > r (
            dritto_traits::create (i, f, this));

          if (!dritto_.present ())
          {
            this->dritto_.set (r);
            continue;
          }
        }

        // rovescio
        //
        if (n.name () == L"rovescio" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< rovescio_type > r (
            rovescio_traits::create (i, f, this));

          if (!rovescio_.present ())
          {
            this->rovescio_.set (r);
            continue;
          }
        }

        // taglio
        //
        if (n.name () == L"taglio" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< taglio_type > r (
            taglio_traits::create (i, f, this));

          if (!taglio_.present ())
          {
            this->taglio_.set (r);
            continue;
          }
        }

        break;
      }

      if (!dritto_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"dritto",
          L"http://gestColl/coins");
      }

      if (!rovescio_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"rovescio",
          L"http://gestColl/coins");
      }

      if (!taglio_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"taglio",
          L"http://gestColl/coins");
      }
    }

    datiArtistici* datiArtistici::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class datiArtistici (*this, f, c);
    }

    datiArtistici::
    ~datiArtistici ()
    {
    }

    // zecchieri
    //

    zecchieri::
    zecchieri ()
    : ::xml_schema::type (),
      zecchiere_ (::xml_schema::flags (), this)
    {
    }

    zecchieri::
    zecchieri (const zecchieri& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      zecchiere_ (x.zecchiere_, f, this)
    {
    }

    zecchieri::
    zecchieri (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      zecchiere_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void zecchieri::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // zecchiere
        //
        if (n.name () == L"zecchiere" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< zecchiere_type > r (
            zecchiere_traits::create (i, f, this));

          this->zecchiere_.push_back (r);
          continue;
        }

        break;
      }
    }

    zecchieri* zecchieri::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class zecchieri (*this, f, c);
    }

    zecchieri::
    ~zecchieri ()
    {
    }

    // stato
    //

    stato::
    stato (const colore_type& colore,
           const motivo_type& motivo)
    : ::xml_schema::type (),
      colore_ (colore, ::xml_schema::flags (), this),
      motivo_ (motivo, ::xml_schema::flags (), this)
    {
    }

    stato::
    stato (const stato& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      colore_ (x.colore_, f, this),
      motivo_ (x.motivo_, f, this)
    {
    }

    stato::
    stato (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      colore_ (f, this),
      motivo_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void stato::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // colore
        //
        if (n.name () == L"colore" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< colore_type > r (
            colore_traits::create (i, f, this));

          if (!colore_.present ())
          {
            this->colore_.set (r);
            continue;
          }
        }

        // motivo
        //
        if (n.name () == L"motivo" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< motivo_type > r (
            motivo_traits::create (i, f, this));

          if (!motivo_.present ())
          {
            this->motivo_.set (r);
            continue;
          }
        }

        break;
      }

      if (!colore_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"colore",
          L"http://gestColl/coins");
      }

      if (!motivo_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"motivo",
          L"http://gestColl/coins");
      }
    }

    stato* stato::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class stato (*this, f, c);
    }

    stato::
    ~stato ()
    {
    }

    // moneta
    //

    moneta::
    moneta (const paese_type& paese,
            const nominale_type& nominale,
            const datiArtistici_type& datiArtistici,
            const datiFisici_type& datiFisici,
            const datiAcquisto_type& datiAcquisto,
            const stato_type& stato,
            const revisione_type& revisione,
            const id_type& id)
    : ::xml_schema::type (),
      ambiti_ (::xml_schema::flags (), this),
      paese_ (paese, ::xml_schema::flags (), this),
      autorita_ (::xml_schema::flags (), this),
      anno_ (::xml_schema::flags (), this),
      nominale_ (nominale, ::xml_schema::flags (), this),
      zecca_ (::xml_schema::flags (), this),
      zecchieri_ (::xml_schema::flags (), this),
      datiArtistici_ (datiArtistici, ::xml_schema::flags (), this),
      datiFisici_ (datiFisici, ::xml_schema::flags (), this),
      datiAcquisto_ (datiAcquisto, ::xml_schema::flags (), this),
      posizione_ (::xml_schema::flags (), this),
      grado_ (::xml_schema::flags (), this),
      note_ (::xml_schema::flags (), this),
      letteratura_ (::xml_schema::flags (), this),
      itemAddizionali_ (::xml_schema::flags (), this),
      stato_ (stato, ::xml_schema::flags (), this),
      revisione_ (revisione, ::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    moneta::
    moneta (const paese_type& paese,
            ::std::auto_ptr< nominale_type >& nominale,
            ::std::auto_ptr< datiArtistici_type >& datiArtistici,
            ::std::auto_ptr< datiFisici_type >& datiFisici,
            ::std::auto_ptr< datiAcquisto_type >& datiAcquisto,
            ::std::auto_ptr< stato_type >& stato,
            const revisione_type& revisione,
            const id_type& id)
    : ::xml_schema::type (),
      ambiti_ (::xml_schema::flags (), this),
      paese_ (paese, ::xml_schema::flags (), this),
      autorita_ (::xml_schema::flags (), this),
      anno_ (::xml_schema::flags (), this),
      nominale_ (nominale, ::xml_schema::flags (), this),
      zecca_ (::xml_schema::flags (), this),
      zecchieri_ (::xml_schema::flags (), this),
      datiArtistici_ (datiArtistici, ::xml_schema::flags (), this),
      datiFisici_ (datiFisici, ::xml_schema::flags (), this),
      datiAcquisto_ (datiAcquisto, ::xml_schema::flags (), this),
      posizione_ (::xml_schema::flags (), this),
      grado_ (::xml_schema::flags (), this),
      note_ (::xml_schema::flags (), this),
      letteratura_ (::xml_schema::flags (), this),
      itemAddizionali_ (::xml_schema::flags (), this),
      stato_ (stato, ::xml_schema::flags (), this),
      revisione_ (revisione, ::xml_schema::flags (), this),
      id_ (id, ::xml_schema::flags (), this)
    {
    }

    moneta::
    moneta (const moneta& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      ambiti_ (x.ambiti_, f, this),
      paese_ (x.paese_, f, this),
      autorita_ (x.autorita_, f, this),
      anno_ (x.anno_, f, this),
      nominale_ (x.nominale_, f, this),
      zecca_ (x.zecca_, f, this),
      zecchieri_ (x.zecchieri_, f, this),
      datiArtistici_ (x.datiArtistici_, f, this),
      datiFisici_ (x.datiFisici_, f, this),
      datiAcquisto_ (x.datiAcquisto_, f, this),
      posizione_ (x.posizione_, f, this),
      grado_ (x.grado_, f, this),
      note_ (x.note_, f, this),
      letteratura_ (x.letteratura_, f, this),
      itemAddizionali_ (x.itemAddizionali_, f, this),
      stato_ (x.stato_, f, this),
      revisione_ (x.revisione_, f, this),
      id_ (x.id_, f, this)
    {
    }

    moneta::
    moneta (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      ambiti_ (f, this),
      paese_ (f, this),
      autorita_ (f, this),
      anno_ (f, this),
      nominale_ (f, this),
      zecca_ (f, this),
      zecchieri_ (f, this),
      datiArtistici_ (f, this),
      datiFisici_ (f, this),
      datiAcquisto_ (f, this),
      posizione_ (f, this),
      grado_ (f, this),
      note_ (f, this),
      letteratura_ (f, this),
      itemAddizionali_ (f, this),
      stato_ (f, this),
      revisione_ (f, this),
      id_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, true);
        this->parse (p, f);
      }
    }

    void moneta::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // ambiti
        //
        if (n.name () == L"ambiti" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< ambiti_type > r (
            ambiti_traits::create (i, f, this));

          if (!this->ambiti_)
          {
            this->ambiti_.set (r);
            continue;
          }
        }

        // paese
        //
        if (n.name () == L"paese" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< paese_type > r (
            paese_traits::create (i, f, this));

          if (!paese_.present ())
          {
            this->paese_.set (r);
            continue;
          }
        }

        // autorita
        //
        if (n.name () == L"autorita" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< autorita_type > r (
            autorita_traits::create (i, f, this));

          if (!this->autorita_)
          {
            this->autorita_.set (r);
            continue;
          }
        }

        // anno
        //
        if (n.name () == L"anno" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< anno_type > r (
            anno_traits::create (i, f, this));

          if (!this->anno_)
          {
            this->anno_.set (r);
            continue;
          }
        }

        // nominale
        //
        if (n.name () == L"nominale" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< nominale_type > r (
            nominale_traits::create (i, f, this));

          if (!nominale_.present ())
          {
            this->nominale_.set (r);
            continue;
          }
        }

        // zecca
        //
        if (n.name () == L"zecca" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< zecca_type > r (
            zecca_traits::create (i, f, this));

          if (!this->zecca_)
          {
            this->zecca_.set (r);
            continue;
          }
        }

        // zecchieri
        //
        if (n.name () == L"zecchieri" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< zecchieri_type > r (
            zecchieri_traits::create (i, f, this));

          if (!this->zecchieri_)
          {
            this->zecchieri_.set (r);
            continue;
          }
        }

        // datiArtistici
        //
        if (n.name () == L"datiArtistici" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< datiArtistici_type > r (
            datiArtistici_traits::create (i, f, this));

          if (!datiArtistici_.present ())
          {
            this->datiArtistici_.set (r);
            continue;
          }
        }

        // datiFisici
        //
        if (n.name () == L"datiFisici" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< datiFisici_type > r (
            datiFisici_traits::create (i, f, this));

          if (!datiFisici_.present ())
          {
            this->datiFisici_.set (r);
            continue;
          }
        }

        // datiAcquisto
        //
        if (n.name () == L"datiAcquisto" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< datiAcquisto_type > r (
            datiAcquisto_traits::create (i, f, this));

          if (!datiAcquisto_.present ())
          {
            this->datiAcquisto_.set (r);
            continue;
          }
        }

        // posizione
        //
        if (n.name () == L"posizione" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< posizione_type > r (
            posizione_traits::create (i, f, this));

          if (!this->posizione_)
          {
            this->posizione_.set (r);
            continue;
          }
        }

        // grado
        //
        if (n.name () == L"grado" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< grado_type > r (
            grado_traits::create (i, f, this));

          if (!this->grado_)
          {
            this->grado_.set (r);
            continue;
          }
        }

        // note
        //
        if (n.name () == L"note" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< note_type > r (
            note_traits::create (i, f, this));

          if (!this->note_)
          {
            this->note_.set (r);
            continue;
          }
        }

        // letteratura
        //
        if (n.name () == L"letteratura" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< letteratura_type > r (
            letteratura_traits::create (i, f, this));

          if (!this->letteratura_)
          {
            this->letteratura_.set (r);
            continue;
          }
        }

        // itemAddizionali
        //
        if (n.name () == L"itemAddizionali" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< itemAddizionali_type > r (
            itemAddizionali_traits::create (i, f, this));

          if (!this->itemAddizionali_)
          {
            this->itemAddizionali_.set (r);
            continue;
          }
        }

        // stato
        //
        if (n.name () == L"stato" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< stato_type > r (
            stato_traits::create (i, f, this));

          if (!stato_.present ())
          {
            this->stato_.set (r);
            continue;
          }
        }

        // revisione
        //
        if (n.name () == L"revisione" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< revisione_type > r (
            revisione_traits::create (i, f, this));

          if (!revisione_.present ())
          {
            this->revisione_.set (r);
            continue;
          }
        }

        break;
      }

      if (!paese_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"paese",
          L"http://gestColl/coins");
      }

      if (!nominale_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"nominale",
          L"http://gestColl/coins");
      }

      if (!datiArtistici_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"datiArtistici",
          L"http://gestColl/coins");
      }

      if (!datiFisici_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"datiFisici",
          L"http://gestColl/coins");
      }

      if (!datiAcquisto_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"datiAcquisto",
          L"http://gestColl/coins");
      }

      if (!stato_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"stato",
          L"http://gestColl/coins");
      }

      if (!revisione_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"revisione",
          L"http://gestColl/coins");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        if (n.name () == L"id" && n.namespace_ ().empty ())
        {
          ::std::auto_ptr< id_type > r (
            id_traits::create (i, f, this));

          this->id_.set (r);
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< wchar_t > (
          L"id",
          L"");
      }
    }

    moneta* moneta::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class moneta (*this, f, c);
    }

    moneta::
    ~moneta ()
    {
    }

    // monete
    //

    monete::
    monete (const info_type& info)
    : ::xml_schema::type (),
      info_ (info, ::xml_schema::flags (), this),
      moneta_ (::xml_schema::flags (), this)
    {
    }

    monete::
    monete (::std::auto_ptr< info_type >& info)
    : ::xml_schema::type (),
      info_ (info, ::xml_schema::flags (), this),
      moneta_ (::xml_schema::flags (), this)
    {
    }

    monete::
    monete (const monete& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (x, f, c),
      info_ (x.info_, f, this),
      moneta_ (x.moneta_, f, this)
    {
    }

    monete::
    monete (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
    : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
      info_ (f, this),
      moneta_ (f, this)
    {
      if ((f & ::xml_schema::flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< wchar_t > p (e, true, false);
        this->parse (p, f);
      }
    }

    void monete::
    parse (::xsd::cxx::xml::dom::parser< wchar_t >& p,
           ::xml_schema::flags f)
    {
      for (; p.more_elements (); p.next_element ())
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< wchar_t > n (
          ::xsd::cxx::xml::dom::name< wchar_t > (i));

        // info
        //
        if (n.name () == L"info" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< info_type > r (
            info_traits::create (i, f, this));

          if (!info_.present ())
          {
            this->info_.set (r);
            continue;
          }
        }

        // moneta
        //
        if (n.name () == L"moneta" && n.namespace_ () == L"http://gestColl/coins")
        {
          ::std::auto_ptr< moneta_type > r (
            moneta_traits::create (i, f, this));

          this->moneta_.push_back (r);
          continue;
        }

        break;
      }

      if (!info_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< wchar_t > (
          L"info",
          L"http://gestColl/coins");
      }
    }

    monete* monete::
    _clone (::xml_schema::flags f,
            ::xml_schema::container* c) const
    {
      return new class monete (*this, f, c);
    }

    monete::
    ~monete ()
    {
    }
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace gestColl
{
  namespace coins
  {
    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (const ::std::wstring& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (
          u, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::gestColl::coins::monete > r (
        ::gestColl::coins::monete_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (const ::std::wstring& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::gestColl::coins::monete > r (
        ::gestColl::coins::monete_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (const ::std::wstring& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (
          u, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::gestColl::coins::monete > r (
        ::gestColl::coins::monete_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::gestColl::coins::monete_ (isrc, f, p);
    }

    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::gestColl::coins::monete_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is);
      return ::gestColl::coins::monete_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::gestColl::coins::monete_ (isrc, f, p);
    }

    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::std::istream& is,
             const ::std::wstring& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0,
        (f & ::xml_schema::flags::keep_dom) == 0);

      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::gestColl::coins::monete_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::std::istream& is,
             const ::std::wstring& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
      return ::gestColl::coins::monete_ (isrc, h, f, p);
    }

    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (
          i, h, p, f));

      h.throw_if_failed< ::xsd::cxx::tree::parsing< wchar_t > > ();

      ::std::auto_ptr< ::gestColl::coins::monete > r (
        ::gestColl::coins::monete_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::gestColl::coins::monete > r (
        ::gestColl::coins::monete_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::parse< wchar_t > (
          i, h, p, f));

      if (!d.get ())
        throw ::xsd::cxx::tree::parsing< wchar_t > ();

      ::std::auto_ptr< ::gestColl::coins::monete > r (
        ::gestColl::coins::monete_ (
          d, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (const ::xercesc::DOMDocument& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
    {
      if (f & ::xml_schema::flags::keep_dom)
      {
        ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
          static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

        ::std::auto_ptr< ::gestColl::coins::monete > r (
          ::gestColl::coins::monete_ (
            c, f | ::xml_schema::flags::own_dom, p));

        return r;
      }

      const ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (n.name () == L"monete" &&
          n.namespace_ () == L"http://gestColl/coins")
      {
        ::std::auto_ptr< ::gestColl::coins::monete > r (
          ::xsd::cxx::tree::traits< ::gestColl::coins::monete, wchar_t >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"monete",
        L"http://gestColl/coins");
    }

    ::std::auto_ptr< ::gestColl::coins::monete >
    monete_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        ((f & ::xml_schema::flags::keep_dom) &&
         !(f & ::xml_schema::flags::own_dom))
        ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
        : 0);

      ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
      const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (f & ::xml_schema::flags::keep_dom)
        doc.setUserData (::xml_schema::dom::tree_node_key,
                         (c.get () ? &c : &d),
                         0);

      if (n.name () == L"monete" &&
          n.namespace_ () == L"http://gestColl/coins")
      {
        ::std::auto_ptr< ::gestColl::coins::monete > r (
          ::xsd::cxx::tree::traits< ::gestColl::coins::monete, wchar_t >::create (
            e, f, 0));
        return r;
      }

      throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
        n.name (),
        n.namespace_ (),
        L"monete",
        L"http://gestColl/coins");
    }
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace gestColl
{
  namespace coins
  {
    void
    operator<< (::xercesc::DOMElement& e, const info& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // titolo
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"titolo",
            L"http://gestColl/coins",
            e));

        s << i.titolo ();
      }

      // proprietario
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"proprietario",
            L"http://gestColl/coins",
            e));

        s << i.proprietario ();
      }

      // inizio
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"inizio",
            L"http://gestColl/coins",
            e));

        s << i.inizio ();
      }

      // ambiti
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ambiti",
            L"http://gestColl/coins",
            e));

        s << i.ambiti ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ambiti& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ambito
      //
      for (ambiti::ambito_const_iterator
           b (i.ambito ().begin ()), n (i.ambito ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ambito",
            L"http://gestColl/coins",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const ambito& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // titolo
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"titolo",
            L"http://gestColl/coins",
            e));

        s << i.titolo ();
      }

      // icon
      //
      if (i.icon ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"icon",
            L"http://gestColl/coins",
            e));

        s << *i.icon ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const autorita& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // nome
      //
      for (autorita::nome_const_iterator
           b (i.nome ().begin ()), n (i.nome ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"nome",
            L"http://gestColl/coins",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const zecca& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // nome
      //
      if (i.nome ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"nome",
            L"http://gestColl/coins",
            e));

        s << *i.nome ();
      }

      // segno
      //
      if (i.segno ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"segno",
            L"http://gestColl/coins",
            e));

        s << *i.segno ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const zecchiere& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // nome
      //
      if (i.nome ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"nome",
            L"http://gestColl/coins",
            e));

        s << *i.nome ();
      }

      // segno
      //
      if (i.segno ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"segno",
            L"http://gestColl/coins",
            e));

        s << *i.segno ();
      }

      // ruolo
      //
      if (i.ruolo ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ruolo",
            L"http://gestColl/coins",
            e));

        s << *i.ruolo ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const legenda& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // testo
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"testo",
            L"http://gestColl/coins",
            e));

        s << i.testo ();
      }

      // scioglimento
      //
      if (i.scioglimento ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"scioglimento",
            L"http://gestColl/coins",
            e));

        s << *i.scioglimento ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const descrizioni& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // descrizione
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"descrizione",
            L"http://gestColl/coins",
            e));

        s << i.descrizione ();
      }

      // legenda
      //
      for (descrizioni::legenda_const_iterator
           b (i.legenda ().begin ()), n (i.legenda ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"legenda",
            L"http://gestColl/coins",
            e));

        s << *b;
      }

      // fileImmagine
      //
      if (i.fileImmagine ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"fileImmagine",
            L"http://gestColl/coins",
            e));

        s << *i.fileImmagine ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const misura& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // unita
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"unita",
            L"http://gestColl/coins",
            e));

        s << i.unita ();
      }

      // valore
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"valore",
            L"http://gestColl/coins",
            e));

        s << ::xml_schema::as_decimal(i.valore ());
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const nominale& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // valuta
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"valuta",
            L"http://gestColl/coins",
            e));

        s << i.valuta ();
      }

      // valore
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"valore",
            L"http://gestColl/coins",
            e));

        s << i.valore ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const libro& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // sigla
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"sigla",
            L"http://gestColl/coins",
            e));

        s << i.sigla ();
      }

      // numero
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"numero",
            L"http://gestColl/coins",
            e));

        s << i.numero ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const asta& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // casa
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"casa",
            L"http://gestColl/coins",
            e));

        s << i.casa ();
      }

      // idAsta
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"idAsta",
            L"http://gestColl/coins",
            e));

        s << i.idAsta ();
      }

      // data
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"data",
            L"http://gestColl/coins",
            e));

        s << i.data ();
      }

      // lotto
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"lotto",
            L"http://gestColl/coins",
            e));

        s << i.lotto ();
      }

      // stima
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"stima",
            L"http://gestColl/coins",
            e));

        s << i.stima ();
      }

      // aggiudicazione
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"aggiudicazione",
            L"http://gestColl/coins",
            e));

        s << i.aggiudicazione ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const documentoAddizionale& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // filename
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"filename",
            L"http://gestColl/coins",
            e));

        s << i.filename ();
      }

      // descrizione
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"descrizione",
            L"http://gestColl/coins",
            e));

        s << i.descrizione ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const documentiAggiuntivi& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // documento
      //
      for (documentiAggiuntivi::documento_const_iterator
           b (i.documento ().begin ()), n (i.documento ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"documento",
            L"http://gestColl/coins",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const letteratura& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // libro
      //
      for (letteratura::libro_const_iterator
           b (i.libro ().begin ()), n (i.libro ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"libro",
            L"http://gestColl/coins",
            e));

        s << *b;
      }

      // asta
      //
      for (letteratura::asta_const_iterator
           b (i.asta ().begin ()), n (i.asta ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"asta",
            L"http://gestColl/coins",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const note& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // nota
      //
      for (note::nota_const_iterator
           b (i.nota ().begin ()), n (i.nota ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"nota",
            L"http://gestColl/coins",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const posizione& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // contenitore
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"contenitore",
            L"http://gestColl/coins",
            e));

        s << i.contenitore ();
      }

      // vassoio
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"vassoio",
            L"http://gestColl/coins",
            e));

        s << i.vassoio ();
      }

      // riga
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"riga",
            L"http://gestColl/coins",
            e));

        s << i.riga ();
      }

      // colonna
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"colonna",
            L"http://gestColl/coins",
            e));

        s << i.colonna ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const datiAcquisto& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // luogo
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"luogo",
            L"http://gestColl/coins",
            e));

        s << i.luogo ();
      }

      // data
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"data",
            L"http://gestColl/coins",
            e));

        s << i.data ();
      }

      // prezzo
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"prezzo",
            L"http://gestColl/coins",
            e));

        s << i.prezzo ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const datiFisici& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // peso
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"peso",
            L"http://gestColl/coins",
            e));

        s << i.peso ();
      }

      // diametro
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"diametro",
            L"http://gestColl/coins",
            e));

        s << i.diametro ();
      }

      // forma
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"forma",
            L"http://gestColl/coins",
            e));

        s << i.forma ();
      }

      // metallo
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"metallo",
            L"http://gestColl/coins",
            e));

        s << i.metallo ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const datiArtistici& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // dritto
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"dritto",
            L"http://gestColl/coins",
            e));

        s << i.dritto ();
      }

      // rovescio
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"rovescio",
            L"http://gestColl/coins",
            e));

        s << i.rovescio ();
      }

      // taglio
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"taglio",
            L"http://gestColl/coins",
            e));

        s << i.taglio ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const zecchieri& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // zecchiere
      //
      for (zecchieri::zecchiere_const_iterator
           b (i.zecchiere ().begin ()), n (i.zecchiere ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"zecchiere",
            L"http://gestColl/coins",
            e));

        s << *b;
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const stato& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // colore
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"colore",
            L"http://gestColl/coins",
            e));

        s << i.colore ();
      }

      // motivo
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"motivo",
            L"http://gestColl/coins",
            e));

        s << i.motivo ();
      }
    }

    void
    operator<< (::xercesc::DOMElement& e, const moneta& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // ambiti
      //
      if (i.ambiti ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"ambiti",
            L"http://gestColl/coins",
            e));

        s << *i.ambiti ();
      }

      // paese
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"paese",
            L"http://gestColl/coins",
            e));

        s << i.paese ();
      }

      // autorita
      //
      if (i.autorita ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"autorita",
            L"http://gestColl/coins",
            e));

        s << *i.autorita ();
      }

      // anno
      //
      if (i.anno ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"anno",
            L"http://gestColl/coins",
            e));

        s << *i.anno ();
      }

      // nominale
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"nominale",
            L"http://gestColl/coins",
            e));

        s << i.nominale ();
      }

      // zecca
      //
      if (i.zecca ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"zecca",
            L"http://gestColl/coins",
            e));

        s << *i.zecca ();
      }

      // zecchieri
      //
      if (i.zecchieri ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"zecchieri",
            L"http://gestColl/coins",
            e));

        s << *i.zecchieri ();
      }

      // datiArtistici
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"datiArtistici",
            L"http://gestColl/coins",
            e));

        s << i.datiArtistici ();
      }

      // datiFisici
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"datiFisici",
            L"http://gestColl/coins",
            e));

        s << i.datiFisici ();
      }

      // datiAcquisto
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"datiAcquisto",
            L"http://gestColl/coins",
            e));

        s << i.datiAcquisto ();
      }

      // posizione
      //
      if (i.posizione ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"posizione",
            L"http://gestColl/coins",
            e));

        s << *i.posizione ();
      }

      // grado
      //
      if (i.grado ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"grado",
            L"http://gestColl/coins",
            e));

        s << *i.grado ();
      }

      // note
      //
      if (i.note ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"note",
            L"http://gestColl/coins",
            e));

        s << *i.note ();
      }

      // letteratura
      //
      if (i.letteratura ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"letteratura",
            L"http://gestColl/coins",
            e));

        s << *i.letteratura ();
      }

      // itemAddizionali
      //
      if (i.itemAddizionali ())
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"itemAddizionali",
            L"http://gestColl/coins",
            e));

        s << *i.itemAddizionali ();
      }

      // stato
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"stato",
            L"http://gestColl/coins",
            e));

        s << i.stato ();
      }

      // revisione
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"revisione",
            L"http://gestColl/coins",
            e));

        s << i.revisione ();
      }

      // id
      //
      {
        ::xercesc::DOMAttr& a (
          ::xsd::cxx::xml::dom::create_attribute (
            L"id",
            e));

        a << i.id ();
      }
    }

    void
    monete_ (::std::ostream& o,
             const ::gestColl::coins::monete& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::gestColl::coins::monete_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    monete_ (::std::ostream& o,
             const ::gestColl::coins::monete& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xsd::cxx::xml::auto_initializer i (
        (f & ::xml_schema::flags::dont_initialize) == 0);

      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::gestColl::coins::monete_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    monete_ (::std::ostream& o,
             const ::gestColl::coins::monete& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::gestColl::coins::monete_ (s, m, f));
      ::xsd::cxx::xml::dom::ostream_format_target t (o);
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    monete_ (::xercesc::XMLFormatTarget& t,
             const ::gestColl::coins::monete& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::gestColl::coins::monete_ (s, m, f));

      ::xsd::cxx::tree::error_handler< wchar_t > h;

      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        h.throw_if_failed< ::xsd::cxx::tree::serialization< wchar_t > > ();
      }
    }

    void
    monete_ (::xercesc::XMLFormatTarget& t,
             const ::gestColl::coins::monete& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::gestColl::coins::monete_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    monete_ (::xercesc::XMLFormatTarget& t,
             const ::gestColl::coins::monete& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::wstring& e,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::gestColl::coins::monete_ (s, m, f));
      if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
      {
        throw ::xsd::cxx::tree::serialization< wchar_t > ();
      }
    }

    void
    monete_ (::xercesc::DOMDocument& d,
             const ::gestColl::coins::monete& s,
             ::xml_schema::flags)
    {
      ::xercesc::DOMElement& e (*d.getDocumentElement ());
      const ::xsd::cxx::xml::qualified_name< wchar_t > n (
        ::xsd::cxx::xml::dom::name< wchar_t > (e));

      if (n.name () == L"monete" &&
          n.namespace_ () == L"http://gestColl/coins")
      {
        e << s;
      }
      else
      {
        throw ::xsd::cxx::tree::unexpected_element < wchar_t > (
          n.name (),
          n.namespace_ (),
          L"monete",
          L"http://gestColl/coins");
      }
    }

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    monete_ (const ::gestColl::coins::monete& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
        ::xsd::cxx::xml::dom::serialize< wchar_t > (
          L"monete",
          L"http://gestColl/coins",
          m, f));

      ::gestColl::coins::monete_ (*d, s, f);
      return d;
    }

    void
    operator<< (::xercesc::DOMElement& e, const monete& i)
    {
      e << static_cast< const ::xml_schema::type& > (i);

      // info
      //
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"info",
            L"http://gestColl/coins",
            e));

        s << i.info ();
      }

      // moneta
      //
      for (monete::moneta_const_iterator
           b (i.moneta ().begin ()), n (i.moneta ().end ());
           b != n; ++b)
      {
        ::xercesc::DOMElement& s (
          ::xsd::cxx::xml::dom::create_element (
            L"moneta",
            L"http://gestColl/coins",
            e));

        s << *b;
      }
    }
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

